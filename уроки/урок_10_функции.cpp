/*
===========================================
УРОК 10: ФУНКЦИИ
===========================================

ЦЕЛИ УРОКА:
- Понять концепцию функций
- Изучить объявление и определение функций
- Научиться передавать параметры в функции
- Освоить возвращаемые значения
- Понять область видимости переменных

ТЕОРЕТИЧЕСКАЯ ЧАСТЬ:

ФУНКЦИИ В C++:

Функция - это именованный блок кода, который выполняет определенную задачу.
Функции позволяют разбить программу на логические части, избежать повторения кода
и сделать программу более читаемой и поддерживаемой.

ЗАЧЕМ НУЖНЫ ФУНКЦИИ:

1. Избежание повторения кода (DRY - Don't Repeat Yourself)
2. Модульность программы
3. Упрощение отладки
4. Переиспользование кода
5. Улучшение читаемости

1. ОБЪЯВЛЕНИЕ ФУНКЦИИ (ПРОТОТИП):

   Прототип функции сообщает компилятору о существовании функции до её использования.
   
   Синтаксис: тип_возврата имя_функции(параметры);
   
   Примеры:
   int add(int a, int b);              // функция возвращает int
   void printMessage();                 // функция ничего не возвращает
   double calculateArea(double r);      // функция возвращает double
   bool isValid(int value);            // функция возвращает bool
   
   Зачем нужны прототипы:
   - Позволяют вызывать функцию до её определения
   - Улучшают организацию кода
   - Помогают компилятору проверять типы
   
   Прототипы обычно размещаются:
   - В начале файла
   - В заголовочных файлах (.h)
   - Перед функцией main()

2. ОПРЕДЕЛЕНИЕ ФУНКЦИИ:

   Определение функции содержит фактический код функции.
   
   Синтаксис:
   тип_возврата имя_функции(параметры) {
       // тело функции
       return значение;  // для функций с возвращаемым значением
   }
   
   Примеры:
   // Функция с возвращаемым значением:
   int add(int a, int b) {
       return a + b;
   }
   
   // Функция без возвращаемого значения:
   void printMessage() {
       cout << "Привет!" << endl;
   }
   
   // Функция с несколькими return:
   int max(int a, int b) {
       if (a > b) {
           return a;
       } else {
           return b;
       }
   }
   
   Важно: Тип возвращаемого значения должен совпадать с типом в прототипе!

3. ВЫЗОВ ФУНКЦИИ:

   Вызов функции выполняет код функции.
   
   Синтаксис: имя_функции(аргументы);
   
   Примеры:
   int result = add(5, 3);        // вызов функции, результат сохраняется
   printMessage();                 // вызов функции без возвращаемого значения
   cout << add(10, 20) << endl;   // вызов функции в выражении
   
   Аргументы (фактические параметры):
   - Значения, передаваемые в функцию при вызове
   - Должны соответствовать типам параметров
   - Передаются в том же порядке, что и параметры

ТИПЫ ФУНКЦИЙ:

1. ФУНКЦИИ С ВОЗВРАЩАЕМЫМ ЗНАЧЕНИЕМ:

   Функция возвращает значение определенного типа.
   
   Примеры:
   int getSum(int a, int b) {
       return a + b;
   }
   
   double calculateArea(double radius) {
       return 3.14159 * radius * radius;
   }
   
   bool isEven(int number) {
       return (number % 2 == 0);
   }
   
   Использование:
   int sum = getSum(5, 3);        // sum = 8
   double area = calculateArea(5); // area = 78.54...
   if (isEven(10)) { ... }        // условие истинно

2. ФУНКЦИИ БЕЗ ВОЗВРАЩАЕМОГО ЗНАЧЕНИЯ (void):

   Функция не возвращает значение (выполняет действия).
   
   Примеры:
   void printMessage() {
       cout << "Привет!" << endl;
   }
   
   void printNumber(int n) {
       cout << "Число: " << n << endl;
   }
   
   void swap(int &a, int &b) {
       int temp = a;
       a = b;
       b = temp;
   }
   
   Использование:
   printMessage();        // просто вызов
   printNumber(42);       // вызов с параметром
   swap(x, y);            // изменяет x и y

3. ФУНКЦИИ БЕЗ ПАРАМЕТРОВ:

   Функция не принимает параметры.
   
   Примеры:
   void printMenu() {
       cout << "1. Опция 1" << endl;
       cout << "2. Опция 2" << endl;
   }
   
   int getRandomNumber() {
       return rand() % 100;
   }
   
   Использование:
   printMenu();
   int num = getRandomNumber();

4. ФУНКЦИИ С ПАРАМЕТРАМИ:

   Функция принимает один или несколько параметров.
   
   Примеры:
   void greet(string name) {
       cout << "Привет, " << name << "!" << endl;
   }
   
   int multiply(int a, int b) {
       return a * b;
   }
   
   Использование:
   greet("Иван");
   int product = multiply(5, 6);

ПАРАМЕТРЫ ФУНКЦИЙ:

Параметры (формальные параметры) - это переменные в объявлении функции.
Аргументы (фактические параметры) - это значения, передаваемые при вызове.

1. ПЕРЕДАЧА ПО ЗНАЧЕНИЮ (копия):

   Создается копия аргумента, изменения не влияют на оригинал.
   
   Пример:
   void increment(int x) {
       x++;  // изменяется только копия
   }
   
   int num = 10;
   increment(num);
   cout << num << endl;  // выводит 10 (не изменилось!)
   
   Когда использовать:
   - Когда не нужно изменять оригинальное значение
   - Для простых типов (int, double, char)
   - Когда изменение не требуется

2. ПЕРЕДАЧА ПО ССЫЛКЕ:

   Функция работает с оригинальной переменной, изменения сохраняются.
   
   Пример:
   void increment(int &x) {
       x++;  // изменяется оригинал
   }
   
   int num = 10;
   increment(num);
   cout << num << endl;  // выводит 11 (изменилось!)
   
   Константная ссылка (для чтения):
   void printValue(const int &x) {
       cout << x << endl;  // можно читать, но не изменять
       // x++;  // ОШИБКА! x константный
   }
   
   Когда использовать:
   - Когда нужно изменить значение
   - Для больших объектов (избегаем копирования)
   - Для возврата нескольких значений

3. ПЕРЕДАЧА ПО УКАЗАТЕЛЮ:

   Функция получает адрес переменной.
   
   Пример:
   void increment(int *x) {
       (*x)++;  // изменяется значение по адресу
   }
   
   int num = 10;
   increment(&num);  // передаем адрес
   cout << num << endl;  // выводит 11
   
   Проверка на nullptr:
   void printValue(int *ptr) {
       if (ptr != nullptr) {
           cout << *ptr << endl;
       }
   }
   
   Когда использовать:
   - Когда указатель может быть nullptr
   - Для массивов
   - В C-стиле кода

4. ПАРАМЕТРЫ ПО УМОЛЧАНИЮ:

   Параметры могут иметь значения по умолчанию.
   
   Пример:
   void greet(string name, string greeting = "Привет") {
       cout << greeting << ", " << name << "!" << endl;
   }
   
   Использование:
   greet("Иван");                    // "Привет, Иван!"
   greet("Иван", "Здравствуй");      // "Здравствуй, Иван!"
   
   Правила:
   - Параметры по умолчанию должны быть справа
   - Нельзя пропускать параметры в середине
   
   Правильно:
   void func(int a, int b = 10, int c = 20);
   func(5);        // a=5, b=10, c=20
   func(5, 15);    // a=5, b=15, c=20
   
   Неправильно:
   void func(int a = 10, int b);  // ОШИБКА! Параметр по умолчанию слева

5. ПЕРЕДАЧА МАССИВОВ:

   Массивы передаются как указатели.
   
   Пример:
   void printArray(int arr[], int size) {
       for (int i = 0; i < size; i++) {
           cout << arr[i] << " ";
       }
   }
   
   // Эквивалентно:
   void printArray(int *arr, int size) {
       // тот же код
   }
   
   Важно: Размер массива нужно передавать отдельно!

ОБЛАСТЬ ВИДИМОСТИ ПЕРЕМЕННЫХ:

Область видимости (scope) определяет, где переменная доступна.

1. ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ:

   Переменные, объявленные внутри функции или блока.
   
   Пример:
   void func() {
       int x = 10;  // локальная переменная
       // x доступна только здесь
   }
   // x НЕ доступна здесь
   
   Особенности:
   - Создаются при входе в блок
   - Уничтожаются при выходе из блока
   - Не видны вне блока
   - Разные функции могут иметь переменные с одинаковыми именами

2. ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ:

   Переменные, объявленные вне всех функций.
   
   Пример:
   int globalVar = 100;  // глобальная переменная
   
   int main() {
       cout << globalVar << endl;  // доступна везде
       return 0;
   }
   
   Особенности:
   - Видны во всех функциях
   - Существуют всю жизнь программы
   - Инициализируются нулями по умолчанию
   
   Рекомендация: Избегайте глобальных переменных! Используйте параметры функций.

3. ПАРАМЕТРЫ ФУНКЦИЙ:

   Параметры функции - это локальные переменные функции.
   
   Пример:
   void func(int param) {  // param - локальная переменная
       // param доступна только здесь
   }

4. БЛОЧНАЯ ОБЛАСТЬ ВИДИМОСТИ:

   Переменные, объявленные в блоках (if, for, while и т.д.).
   
   Пример:
   void func() {
       int x = 10;
       if (true) {
           int y = 20;  // локальная для блока if
           // x и y доступны здесь
       }
       // y НЕ доступна здесь
       // x доступна здесь
   }

5. СКРЫТИЕ ПЕРЕМЕННЫХ:

   Локальная переменная скрывает глобальную с тем же именем.
   
   Пример:
   int x = 100;  // глобальная
   
   void func() {
       int x = 10;  // локальная (скрывает глобальную)
       cout << x << endl;  // выводит 10 (локальная)
   }
   
   Доступ к глобальной переменной:
   int x = 100;
   
   void func() {
       int x = 10;
       cout << x << endl;        // 10 (локальная)
       cout << ::x << endl;      // 100 (глобальная, оператор ::)
   }

РЕКУРСИВНЫЕ ФУНКЦИИ:

Рекурсивная функция вызывает сама себя.

Пример (факториал):
int factorial(int n) {
    if (n <= 1) {
        return 1;  // базовый случай
    }
    return n * factorial(n - 1);  // рекурсивный вызов
}

Особенности:
- Должен быть базовый случай (условие выхода)
- Каждый вызов приближает к базовому случаю
- Может быть неэффективна (много вызовов)

Пример (числа Фибоначчи):
int fibonacci(int n) {
    if (n <= 1) {
        return n;  // базовый случай
    }
    return fibonacci(n - 1) + fibonacci(n - 2);  // рекурсия
}

ПЕРЕГРУЗКА ФУНКЦИЙ:

В C++ можно иметь несколько функций с одним именем, но разными параметрами.

Пример:
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}

int add(int a, int b, int c) {
    return a + b + c;
}

Использование:
int sum1 = add(5, 3);           // вызывает первую функцию
double sum2 = add(5.5, 3.2);    // вызывает вторую функцию
int sum3 = add(1, 2, 3);        // вызывает третью функцию

Правила перегрузки:
- Функции должны отличаться количеством или типами параметров
- Нельзя перегружать только по типу возвращаемого значения
- Компилятор выбирает функцию по типам аргументов

ВСТРОЕННЫЕ ФУНКЦИИ (inline):

Ключевое слово inline подсказывает компилятору встроить код функции.

Пример:
inline int square(int x) {
    return x * x;
}

Особенности:
- Код функции вставляется в место вызова (может быть быстрее)
- Увеличивает размер программы
- Компилятор может проигнорировать inline
- Используется для маленьких функций

СТАТИЧЕСКИЕ ПЕРЕМЕННЫЕ:

Статическая переменная сохраняет значение между вызовами.

Пример:
void counter() {
    static int count = 0;  // инициализируется один раз
    count++;
    cout << "Вызовов: " << count << endl;
}

counter();  // Вызовов: 1
counter();  // Вызовов: 2
counter();  // Вызовов: 3

Особенности:
- Инициализируется один раз
- Сохраняет значение между вызовами
- Существует всю жизнь программы

ПРИМЕРЫ КОДА:
*/

#include <iostream>
using namespace std;

// Прототипы функций
int add(int a, int b);
void printMessage();
double calculateArea(double radius);
void swapValues(int &a, int &b);
int factorial(int n);

// Глобальная переменная
int globalVar = 100;

int main() {
    // Вызов функции с возвращаемым значением
    cout << "=== ФУНКЦИИ С ВОЗВРАЩАЕМЫМ ЗНАЧЕНИЕМ ===" << endl;
    int result = add(5, 3);
    cout << "5 + 3 = " << result << endl;
    
    // Вызов функции без возвращаемого значения
    cout << "\n=== ФУНКЦИИ БЕЗ ВОЗВРАЩАЕМОГО ЗНАЧЕНИЯ ===" << endl;
    printMessage();
    
    // Функция с параметром
    cout << "\n=== ФУНКЦИЯ С ПАРАМЕТРОМ ===" << endl;
    double area = calculateArea(5.0);
    cout << "Площадь круга с радиусом 5: " << area << endl;
    
    // Функция с передачей по ссылке
    cout << "\n=== ПЕРЕДАЧА ПО ССЫЛКЕ ===" << endl;
    int x = 10, y = 20;
    cout << "До обмена: x = " << x << ", y = " << y << endl;
    swapValues(x, y);
    cout << "После обмена: x = " << x << ", y = " << y << endl;
    
    // Рекурсивная функция
    cout << "\n=== РЕКУРСИВНАЯ ФУНКЦИЯ ===" << endl;
    int n = 5;
    cout << "Факториал " << n << " = " << factorial(n) << endl;
    
    return 0;
}

// Определение функции сложения
int add(int a, int b) {
    return a + b;
}

// Определение функции печати сообщения
void printMessage() {
    cout << "Привет из функции!" << endl;
}

// Определение функции вычисления площади круга
double calculateArea(double radius) {
    const double PI = 3.14159;
    return PI * radius * radius;
}

// Определение функции обмена значений
void swapValues(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

// Определение рекурсивной функции
int factorial(int n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

/*
ПРАКТИЧЕСКИЕ УПРАЖНЕНИЯ:

Упражнение 1: Функция для поиска максимума
Создай функцию для поиска максимального из трех чисел:
*/

int findMax(int a, int b, int c) {
    int max = a;
    if (b > max) max = b;
    if (c > max) max = c;
    return max;
}

void exercise1() {
    int x, y, z;
    cout << "Введите три числа: ";
    cin >> x >> y >> z;
    
    int max = findMax(x, y, z);
    cout << "Максимальное число: " << max << endl;
}

/*
Упражнение 2: Функция для проверки простого числа
Создай функцию для проверки, является ли число простым:
*/

bool isPrime(int n) {
    if (n < 2) return false;
    if (n == 2) return true;
    if (n % 2 == 0) return false;
    
    for (int i = 3; i * i <= n; i += 2) {
        if (n % i == 0) return false;
    }
    return true;
}

void exercise2() {
    int num;
    cout << "Введите число для проверки: ";
    cin >> num;
    
    if (isPrime(num)) {
        cout << num << " - простое число" << endl;
    } else {
        cout << num << " - не простое число" << endl;
    }
}

/*
Упражнение 3: Функция для вычисления НОД
Создай функцию для вычисления наибольшего общего делителя:
*/

int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

void exercise3() {
    int a, b;
    cout << "Введите два числа: ";
    cin >> a >> b;
    
    int result = gcd(a, b);
    cout << "НОД(" << a << ", " << b << ") = " << result << endl;
}

/*
Упражнение 4: Функция для вычисления степени
Создай функцию для вычисления степени числа:
*/

double power(double base, int exponent) {
    if (exponent == 0) return 1;
    if (exponent < 0) return 1.0 / power(base, -exponent);
    
    double result = 1;
    for (int i = 0; i < exponent; i++) {
        result *= base;
    }
    return result;
}

void exercise4() {
    double base;
    int exponent;
    cout << "Введите основание: ";
    cin >> base;
    cout << "Введите степень: ";
    cin >> exponent;
    
    double result = power(base, exponent);
    cout << base << "^" << exponent << " = " << result << endl;
}

/*
Упражнение 5: Функция для работы с массивом
Создай функцию для поиска элемента в массиве:
*/

int findElement(int arr[], int size, int target) {
    for (int i = 0; i < size; i++) {
        if (arr[i] == target) {
            return i;
        }
    }
    return -1; // элемент не найден
}

void exercise5() {
    int arr[10] = {5, 8, 12, 3, 9, 15, 7, 2, 11, 6};
    int target;
    
    cout << "Массив: ";
    for (int i = 0; i < 10; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    cout << "Введите число для поиска: ";
    cin >> target;
    
    int index = findElement(arr, 10, target);
    if (index != -1) {
        cout << "Элемент найден на позиции " << index << endl;
    } else {
        cout << "Элемент не найден" << endl;
    }
}

/*
ДОМАШНИЕ ЗАДАНИЯ:

Задание 1: Функция для сортировки массива
Создай функцию для сортировки массива методом пузырька:
- Входные параметры: массив и его размер
- Функция должна изменить исходный массив
- Используй передачу по указателю

Задание 2: Функция для работы со строками
Создай функцию для подсчета слов в строке:
- Входной параметр: строка
- Возвращаемое значение: количество слов
- Слова разделены пробелами

Задание 3: Функция для работы с геометрией
Создай функции для работы с геометрическими фигурами:
- Функция для вычисления площади треугольника
- Функция для вычисления периметра прямоугольника
- Функция для проверки, можно ли построить треугольник

ПРОВЕРОЧНЫЕ ВОПРОСЫ:

1. Что такое функция?
2. В чем разница между объявлением и определением функции?
3. Что такое прототип функции?
4. Как передать параметры в функцию?
5. Что такое область видимости переменных?
6. Что такое рекурсия?
7. Можно ли функция возвращать несколько значений?

ЧТО ДАЛЬШЕ:
На следующем уроке мы изучим:
- Работа с файлами
- Чтение из файла
- Запись в файл
- Обработка ошибок при работе с файлами
- Различные режимы открытия файлов

ВРЕМЯ ИЗУЧЕНИЯ: 50-60 минут
ВРЕМЯ ПРАКТИКИ: 40-50 минут
ОБЩЕЕ ВРЕМЯ: 1.5-2 часа

===========================================
*/

#include <iostream>
using namespace std;

int main() {
    // Основная программа
    cout << "=== УРОК 10: ФУНКЦИИ ===" << endl;
    
    // Выполняем упражнения
    cout << "\n=== УПРАЖНЕНИЕ 1: ПОИСК МАКСИМУМА ===" << endl;
    exercise1();
    
    cout << "\n=== УПРАЖНЕНИЕ 2: ПРОВЕРКА ПРОСТОГО ЧИСЛА ===" << endl;
    exercise2();
    
    cout << "\n=== УПРАЖНЕНИЕ 3: ВЫЧИСЛЕНИЕ НОД ===" << endl;
    exercise3();
    
    cout << "\n=== УПРАЖНЕНИЕ 4: ВЫЧИСЛЕНИЕ СТЕПЕНИ ===" << endl;
    exercise4();
    
    cout << "\n=== УПРАЖНЕНИЕ 5: ПОИСК В МАССИВЕ ===" << endl;
    exercise5();
    
    return 0;
}
























