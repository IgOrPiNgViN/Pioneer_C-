/*
===========================================
УРОК 14: КЛАССЫ, ОБЪЕКТЫ И ОСНОВЫ ООП
===========================================

ЦЕЛИ УРОКА:
- Понять, что такое объектно-ориентированное программирование (ООП)
- Разобраться в трёх главных принципах ООП
- Научиться создавать классы и объекты
- Глубоко понять инкапсуляцию на реальных примерах
- Освоить уровни доступа, геттеры и сеттеры
- Понять разницу между классами и структурами
- Понять константные методы и друзей класса

=============================================
ЧАСТЬ 1: ЧТО ТАКОЕ ООП И ЗАЧЕМ ОНО НУЖНО
=============================================

ТЕОРЕТИЧЕСКАЯ ЧАСТЬ:

ДО ООП: ПРОЦЕДУРНОЕ ПРОГРАММИРОВАНИЕ

До этого урока мы писали код в процедурном стиле:
- Данные хранились в переменных отдельно
- Функции обрабатывали эти данные отдельно
- Данные и функции никак не были связаны между собой

Пример проблемы процедурного подхода:
   string studentName = "Иван";
   int studentAge = 15;
   double studentGrade = 4.5;

   string teacherName = "Мария Ивановна";
   int teacherAge = 35;
   string teacherSubject = "Математика";

   // Кто мешает случайно присвоить учителю оценку студента?
   // Кто мешает записать возраст -100?
   // Если студентов 30 - нужно 30 отдельных переменных для каждого поля!

Это как если бы в больнице все документы пациентов лежали в одной куче
на столе - любой может взять, изменить, потерять.

ООП - ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ

ООП - это способ организации кода, где данные и функции объединяются
в единые блоки - ОБЪЕКТЫ.

Аналогия из реальной жизни:

Представь школу. В ней есть:
- Ученики (у каждого своё имя, класс, оценки)
- Учителя (у каждого своё имя, предмет, стаж)
- Классные комнаты (у каждой свой номер, вместимость)

Каждый ученик - это ОБЪЕКТ. У него есть:
- ДАННЫЕ (имя, возраст, оценки) - это ПОЛЯ
- ДЕЙСТВИЯ (учиться, сдавать экзамен, получать оценку) - это МЕТОДЫ

Все ученики похожи по структуре (у всех есть имя и оценки),
но отличаются значениями (у Ивана оценка 5, у Пети - 3).
Описание "что такое ученик" - это КЛАСС.
Конкретный Иван или Петя - это ОБЪЕКТ (экземпляр класса).

ЗАЧЕМ НУЖНО ООП:

1. ОРГАНИЗАЦИЯ: Данные и функции собраны вместе, а не разбросаны по всей программе
   Как в школе: документы каждого ученика в отдельной папке, а не в общей куче

2. ЗАЩИТА ДАННЫХ: Нельзя случайно испортить данные объекта
   Как в банке: нельзя просто так зайти в хранилище - нужно пройти через кассира

3. ПЕРЕИСПОЛЬЗОВАНИЕ: Один раз описал класс - создавай сколько угодно объектов
   Как чертёж дома: один чертёж - можно построить 100 одинаковых домов

4. МАСШТАБИРУЕМОСТЬ: Легко добавлять новые возможности
   Как конструктор LEGO: добавляешь новые детали, не ломая старые

5. БЛИЗОСТЬ К РЕАЛЬНОМУ МИРУ: Программа описывает реальные сущности
   Ученик в программе ведёт себя как ученик в жизни

=============================================
ЧАСТЬ 2: ТРИ ГЛАВНЫХ ПРИНЦИПА ООП
=============================================

ООП основано на трёх китах (парадигмах). В этом уроке мы подробно
изучим первый. Остальные два - в следующих уроках.

1. ИНКАПСУЛЯЦИЯ (этот урок)
   "Спрячь внутренности, покажи только кнопки"
   
   Реальный пример: ТЕЛЕВИЗОР
   - Внутри: микросхемы, провода, транзисторы (СКРЫТО)
   - Снаружи: пульт с кнопками (ИНТЕРФЕЙС)
   - Ты не лезешь внутрь телевизора, чтобы переключить канал
   - Ты нажимаешь кнопку на пульте - и телевизор сам всё делает
   - Если бы каждый лез внутрь - телевизоры бы постоянно ломались
   
   В программировании:
   - Данные (поля) СКРЫТЫ внутри класса (private)
   - Доступ к данным ТОЛЬКО через методы (public)
   - Методы ПРОВЕРЯЮТ правильность данных перед изменением
   - Внешний код НЕ МОЖЕТ напрямую испортить данные

2. НАСЛЕДОВАНИЕ (урок 16)
   "Создавай новое на основе старого"
   
   Реальный пример: Все собаки - животные. Все животные умеют дышать.
   Значит, собаке не нужно заново "учиться" дышать - она НАСЛЕДУЕТ
   это от класса "Животное".

3. ПОЛИМОРФИЗМ (урок 17)
   "Одна команда - разное поведение"
   
   Реальный пример: Команда "Голос!" для собаки - "Гав!",
   для кошки - "Мяу!", для попугая - "Привет!".
   Одна и та же команда, но каждое животное выполняет её по-своему.

=============================================
ЧАСТЬ 3: КЛАССЫ И ОБЪЕКТЫ
=============================================

КЛАСС - это ЧЕРТЁЖ, ШАБЛОН, ОПИСАНИЕ.
ОБЪЕКТ - это КОНКРЕТНАЯ ВЕЩЬ, созданная по этому чертежу.

Аналогии:
   Класс "Автомобиль"     ->  Объект: конкретная Toyota Camry с номером А123БВ
   Класс "Ученик"          ->  Объект: конкретный Иван Петров из 8Б
   Класс "Телефон"         ->  Объект: твой конкретный iPhone/Samsung
   Класс "Рецепт торта"    ->  Объект: конкретный торт на столе

Класс описывает:
- Какие ДАННЫЕ есть у объекта (поля / свойства)
- Какие ДЕЙСТВИЯ может выполнять объект (методы / функции)

Пример:
   Класс "Ученик":
      Данные: имя, возраст, класс, средний балл
      Действия: учиться, сдать экзамен, получить оценку, показать информацию

   Объект 1: Иван, 15 лет, 9А, средний балл 4.5
   Объект 2: Мария, 14 лет, 8Б, средний балл 5.0

Каждый объект НЕЗАВИСИМ - изменение данных Ивана не влияет на Марию.

=============================================
ЧАСТЬ 4: ИНКАПСУЛЯЦИЯ ПОДРОБНО
=============================================

Инкапсуляция состоит из ДВУХ идей:

ИДЕЯ 1: ОБЪЕДИНЕНИЕ данных и методов в одном месте (классе)

   БЕЗ инкапсуляции (плохо):
      string name = "Иван";
      int age = 15;
      void printInfo() { cout << name << ", " << age << endl; }
      // name, age и printInfo - три отдельные вещи, ничем не связанные
      // любой код может изменить name и age как угодно

   С инкапсуляцией (хорошо):
      class Student {
          string name;
          int age;
          void printInfo() { ... }
      };
      // name, age и printInfo - единое целое внутри класса Student

ИДЕЯ 2: СОКРЫТИЕ внутренних данных и контроль доступа

   Реальный пример: БАНКОМАТ
   
   Что СКРЫТО (private):
   - Сколько денег внутри банкомата
   - Как работает механизм выдачи купюр
   - Алгоритм проверки ПИН-кода
   - Связь с банковским сервером
   
   Что ДОСТУПНО (public):
   - Вставить карту
   - Ввести ПИН-код
   - Выбрать сумму
   - Получить деньги
   - Посмотреть баланс
   
   Почему это важно:
   - Ты НЕ МОЖЕШЬ просто открыть банкомат и взять деньги
   - Ты ДОЛЖЕН пройти проверку (ПИН-код)
   - Банкомат НЕ ВЫДАСТ больше, чем есть на счёте (валидация)
   - Если бы банкомат был "открытым" - все бы брали деньги без проверки

   В программировании то же самое:
   
   БЕЗ сокрытия (опасно):
      class Student {
      public:
          int age;  // любой может написать: student.age = -500;
      };
   
   С сокрытием (безопасно):
      class Student {
      private:
          int age;  // напрямую изменить нельзя
      public:
          void setAge(int a) {
              if (a >= 0 && a <= 150) {  // проверка!
                  age = a;
              }
              // если возраст неправильный - ничего не произойдёт
          }
      };

   Ещё пример: ТЕРМОСТАТ
   
   private: текущая температура, целевая температура, включён ли нагрев
   public:  установить желаемую температуру, узнать текущую температуру
   
   Ты не лезешь внутрь термостата менять провода.
   Ты просто крутишь ручку (вызываешь метод setTemperature).
   Термостат САМ решает, включить нагрев или охлаждение.

УРОВНИ ДОСТУПА:

В C++ есть три уровня доступа к членам класса:

1. private (приватный) - ТОЛЬКО внутри класса
   - Поля и методы видны ТОЛЬКО другим методам этого же класса
   - Снаружи класса обратиться к ним НЕВОЗМОЖНО
   - В классах (class) это уровень ПО УМОЛЧАНИЮ
   - Используется для: данных, внутренней логики

2. public (публичный) - ДОСТУПЕН ВСЕМ
   - Поля и методы видны ОТКУДА УГОДНО
   - Это "интерфейс" класса - то, что видят другие
   - Используется для: методов, которые вызывает внешний код

3. protected (защищённый) - класс + наследники
   - Видны внутри класса И в классах-наследниках
   - Снаружи - недоступны
   - Подробнее в уроке про наследование (урок 16)

Таблица доступа:
                  | private | protected | public
   Сам класс     |   ДА    |    ДА     |   ДА
   Наследники    |   НЕТ   |    ДА     |   ДА
   Внешний код   |   НЕТ   |    НЕТ    |   ДА

ГЕТТЕРЫ И СЕТТЕРЫ:

Геттер (getter) - метод для ПОЛУЧЕНИЯ значения приватного поля
Сеттер (setter) - метод для УСТАНОВКИ значения приватного поля

Зачем они нужны, если можно просто сделать поле public?

1. ВАЛИДАЦИЯ: сеттер может проверить данные перед записью
   void setAge(int a) {
       if (a >= 0 && a <= 150) age = a;  // возраст от 0 до 150
   }

2. ТОЛЬКО ЧТЕНИЕ: можно сделать геттер без сеттера
   string getName() { return name; }
   // Имя можно узнать, но нельзя изменить извне

3. ЛОГИКА ПРИ ИЗМЕНЕНИИ: можно добавить действия при изменении
   void setScore(int s) {
       score = s;
       if (score >= 90) cout << "Отлично!" << endl;  // автоматическая реакция
   }

4. ГИБКОСТЬ: можно изменить внутреннюю реализацию, не ломая внешний код
   Сначала: хранили возраст как int
   Потом: стали вычислять из даты рождения
   Геттер getAge() работает так же, внешний код не заметил изменений

РАЗНИЦА МЕЖДУ КЛАССАМИ И СТРУКТУРАМИ:

В C++ class и struct почти одинаковы, но:
- class: по умолчанию всё private (для ООП)
- struct: по умолчанию всё public (для простых данных)

   class MyClass {
       int x;  // private по умолчанию - снаружи недоступно
   };

   struct MyStruct {
       int x;  // public по умолчанию - снаружи доступно
   };

Рекомендация:
- Используй class, когда есть логика (методы, проверки, инкапсуляция)
- Используй struct, когда просто группируешь данные без логики

=============================================
ЧАСТЬ 5: ДОПОЛНИТЕЛЬНЫЕ ВОЗМОЖНОСТИ КЛАССОВ
=============================================

а) КОНСТАНТНЫЕ МЕТОДЫ (const):

Геттеры не должны изменять объект, поэтому их делают const:

   string getName() const {  // const означает, что метод не изменяет объект
       return name;
   }

Преимущества const методов:
- Можно вызывать на константных объектах
- Компилятор проверит, что метод не изменяет данные
- Документирует намерение программиста

б) ИНВАРИАНТЫ КЛАССА:

Инвариант класса - это условие, которое всегда должно быть истинным для объекта.

Пример: класс Date (дата)
- Месяц всегда от 1 до 12
- День соответствует месяцу
- Год положительный

   class Date {
   private:
       int day, month, year;
       
       bool isValidDate(int d, int m, int y) {
           if (y < 1 || m < 1 || m > 12 || d < 1) return false;
           
           int daysInMonth[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
           
           // Проверка високосного года
           if (y % 4 == 0 && (y % 100 != 0 || y % 400 == 0)) {
               daysInMonth[1] = 29;
           }
           
           return d <= daysInMonth[m - 1];
       }
       
   public:
       bool setDate(int d, int m, int y) {
           if (isValidDate(d, m, y)) {
               day = d;
               month = m;
               year = y;
               return true;
           }
           return false;
       }
   };

в) ДРУЗЬЯ КЛАССА (friend):

Иногда нужно дать доступ к приватным членам другому классу или функции.
Для этого используется ключевое слово friend.

   class Secret {
   private:
       int secretNumber;
       
       friend void showSecret(const Secret& s);  // функция-друг
       friend class SecretViewer;  // класс-друг
   };

   void showSecret(const Secret& s) {
       cout << s.secretNumber;  // имеет доступ к private членам
   }

Важно: friend нарушает инкапсуляцию, используйте осторожно!

=============================================
ЧАСТЬ 6: СИНТАКСИС
=============================================

СИНТАКСИС УРОКА:

1. Объявление класса:

   class ИмяКласса {
   private:
       тип поле1;           // приватные данные
       тип поле2;
   public:
       void метод1() { }    // публичные методы
       тип метод2() { }
   };  // <-- ОБЯЗАТЕЛЬНА точка с запятой после }

2. Создание объекта:

   ИмяКласса имяОбъекта;
   // Пример:
   Student student1;
   Student student2;

3. Вызов метода объекта (оператор точка):

   объект.метод(аргументы);
   // Пример:
   student1.setName("Иван");
   student1.displayInfo();
   string name = student1.getName();

4. Геттер (получение значения, всегда const!):

   тип getПоле() const {
       return поле;
   }
   // Пример:
   string getName() const { return name; }
   int getAge() const { return age; }

5. Сеттер (установка значения с проверкой):

   void setПоле(тип значение) {
       if (условие_проверки) {
           поле = значение;
       }
   }
   // Пример:
   void setAge(int a) {
       if (a >= 0 && a <= 150) {
           age = a;
       }
   }

6. Определение метода ВНЕ класса:

   class MyClass {
   public:
       void myMethod();  // только объявление (без тела)
   };

   void MyClass::myMethod() {   // определение через ::
       // тело метода
   }

7. Обращение к private полю ИЗВНЕ:

   Student s;
   // s.age = 15;          // ОШИБКА! age - private
   s.setAge(15);           // ПРАВИЛЬНО - через сеттер
   cout << s.getAge();     // ПРАВИЛЬНО - через геттер

8. Константный метод: тип имя() const { return поле; }

9. Друг класса: friend void func(MyClass& obj);

ПРИМЕРЫ КОДА:
*/

#include <iostream>
#include <string>
using namespace std;

// =============================================
// ПРИМЕР 1: Простой класс Student
// Демонстрирует основы: поля, методы, инкапсуляцию
// =============================================
class Student {
private:
    // Приватные поля - СКРЫТЫ от внешнего кода
    string name;
    int age;
    double grade;

public:
    // --- Сеттеры (установка значений с проверкой) ---
    
    void setName(string n) {
        if (n.length() > 0) {  // имя не должно быть пустым
            name = n;
        }
    }
    
    void setAge(int a) {
        if (a >= 6 && a <= 18) {  // школьный возраст
            age = a;
        } else {
            cout << "Ошибка: возраст школьника от 6 до 18!" << endl;
        }
    }
    
    void setGrade(double g) {
        if (g >= 1.0 && g <= 5.0) {  // оценка от 1 до 5
            grade = g;
        } else {
            cout << "Ошибка: оценка от 1.0 до 5.0!" << endl;
        }
    }
    
    // --- Геттеры (получение значений, const - не изменяют объект) ---
    
    string getName() const { return name; }
    int getAge() const { return age; }
    double getGrade() const { return grade; }
    
    // --- Другие методы ---
    
    void displayInfo() const {
        cout << "Ученик: " << name 
             << ", возраст: " << age 
             << ", средний балл: " << grade << endl;
    }
    
    bool isExcellent() const {
        return grade >= 4.5;  // отличник, если балл >= 4.5
    }
};

// =============================================
// ПРИМЕР 2: Класс BankAccount
// Показывает ЗАЧЕМ нужна инкапсуляция
// =============================================
class BankAccount {
private:
    string owner;       // владелец счёта
    double balance;     // баланс (СКРЫТ - нельзя просто так изменить)
    
public:
    // Настройка счёта
    void setup(string ownerName, double initialBalance) {
        owner = ownerName;
        if (initialBalance >= 0) {
            balance = initialBalance;
        } else {
            balance = 0;
        }
    }
    
    // Внести деньги (с проверкой)
    void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            cout << owner << ": внесено " << amount << " руб. ";
            cout << "Баланс: " << balance << " руб." << endl;
        } else {
            cout << "Ошибка: сумма должна быть положительной!" << endl;
        }
    }
    
    // Снять деньги (с проверкой)
    void withdraw(double amount) {
        if (amount <= 0) {
            cout << "Ошибка: сумма должна быть положительной!" << endl;
        } else if (amount > balance) {
            cout << "Ошибка: недостаточно средств! ";
            cout << "Баланс: " << balance << " руб." << endl;
        } else {
            balance -= amount;
            cout << owner << ": снято " << amount << " руб. ";
            cout << "Баланс: " << balance << " руб." << endl;
        }
    }
    
    // Узнать баланс (только чтение - нет сеттера для balance!)
    double getBalance() const { return balance; }
    string getOwner() const { return owner; }
    
    void displayInfo() const {
        cout << "Счёт: " << owner << ", баланс: " << balance << " руб." << endl;
    }
};

// =============================================
// Функция с примерами из урока
// =============================================
void examples() {
    // --- Пример работы с классом Student ---
    cout << "=== ПРИМЕР 1: КЛАСС STUDENT ===" << endl;
    
    Student student1;
    student1.setName("Иван");
    student1.setAge(15);
    student1.setGrade(4.8);
    student1.displayInfo();
    cout << "Отличник: " << (student1.isExcellent() ? "Да" : "Нет") << endl;
    
    Student student2;
    student2.setName("Мария");
    student2.setAge(14);
    student2.setGrade(3.5);
    student2.displayInfo();
    cout << "Отличник: " << (student2.isExcellent() ? "Да" : "Нет") << endl;
    
    // Попытка задать неправильные данные:
    cout << "\n--- Проверка валидации ---" << endl;
    student1.setAge(-5);     // Ошибка! Не установится
    student1.setGrade(10.0); // Ошибка! Не установится
    student1.displayInfo();  // Данные остались прежними
    
    // student1.age = 100;  // ОШИБКА КОМПИЛЯЦИИ! age - private
    // Инкапсуляция защищает данные от неправильного использования
    
    // --- Пример работы с классом BankAccount ---
    cout << "\n=== ПРИМЕР 2: КЛАСС BANKACCOUNT ===" << endl;
    
    BankAccount account;
    account.setup("Петров И.И.", 5000.0);
    account.displayInfo();
    
    account.deposit(2000.0);    // Внести 2000
    account.withdraw(1500.0);   // Снять 1500
    account.withdraw(10000.0);  // Попытка снять больше баланса
    account.deposit(-500.0);    // Попытка внести отрицательную сумму
    
    // account.balance = 1000000;  // ОШИБКА КОМПИЛЯЦИИ! balance - private
    // Нельзя просто приписать себе миллион - только через deposit()
}

// =============================================
// ПРАКТИЧЕСКИЕ УПРАЖНЕНИЯ
// =============================================

// Упражнение 1: Класс Rectangle (Прямоугольник)
// Демонстрирует инкапсуляцию: стороны не могут быть отрицательными
class Rectangle {
private:
    double width;
    double height;
    
public:
    void setDimensions(double w, double h) {
        if (w > 0 && h > 0) {
            width = w;
            height = h;
        } else {
            cout << "Ошибка: стороны должны быть положительными!" << endl;
        }
    }
    
    double getWidth() const { return width; }
    double getHeight() const { return height; }
    
    double getArea() const {
        return width * height;
    }
    
    double getPerimeter() const {
        return 2 * (width + height);
    }
    
    bool isSquare() const {
        return width == height;
    }
    
    void displayInfo() const {
        cout << "Прямоугольник " << width << " x " << height << endl;
        cout << "  Площадь: " << getArea() << endl;
        cout << "  Периметр: " << getPerimeter() << endl;
        cout << "  Квадрат: " << (isSquare() ? "Да" : "Нет") << endl;
    }
};

void exercise1() {
    Rectangle rect1;
    rect1.setDimensions(5.0, 3.0);
    rect1.displayInfo();
    
    Rectangle rect2;
    rect2.setDimensions(4.0, 4.0);
    rect2.displayInfo();
    
    Rectangle rect3;
    rect3.setDimensions(-2.0, 5.0);  // Ошибка! Не установится
}

// Упражнение 2: Класс Counter (Счётчик)
// Демонстрирует: методы изменяют данные контролируемо
class Counter {
private:
    int value;
    int maxValue;
    
public:
    void setup(int startValue, int maxVal) {
        value = 0;
        if (startValue >= 0) value = startValue;
        maxValue = maxVal;
    }
    
    void increment() {
        if (value < maxValue) {
            value++;
            cout << "  +1 -> " << value << endl;
        } else {
            cout << "  Достигнут максимум (" << maxValue << ")!" << endl;
        }
    }
    
    void decrement() {
        if (value > 0) {
            value--;
            cout << "  -1 -> " << value << endl;
        } else {
            cout << "  Счётчик на нуле!" << endl;
        }
    }
    
    void reset() {
        value = 0;
        cout << "  Сброс -> 0" << endl;
    }
    
    int getValue() const { return value; }
    
    void displayInfo() const {
        cout << "Счётчик: " << value << " / " << maxValue << endl;
    }
};

void exercise2() {
    Counter counter;
    counter.setup(0, 5);
    counter.displayInfo();
    
    counter.increment();
    counter.increment();
    counter.increment();
    counter.increment();
    counter.increment();
    counter.increment();  // Попытка превысить максимум
    counter.displayInfo();
    
    counter.decrement();
    counter.displayInfo();
    
    counter.reset();
    counter.displayInfo();
}

// Упражнение 3: Класс Book (Книга в библиотеке)
// Демонстрирует: объект моделирует реальную сущность
class Book {
private:
    string title;
    string author;
    bool isAvailable;
    
public:
    void setup(string t, string a) {
        title = t;
        author = a;
        isAvailable = true;  // новая книга доступна
    }
    
    // Геттеры (const - не изменяют объект)
    string getTitle() const { return title; }
    string getAuthor() const { return author; }
    bool getAvailable() const { return isAvailable; }
    
    // Методы с логикой
    void borrow() {
        if (isAvailable) {
            isAvailable = false;
            cout << "Книга '" << title << "' выдана читателю" << endl;
        } else {
            cout << "Книга '" << title << "' уже на руках!" << endl;
        }
    }
    
    void returnBook() {
        if (!isAvailable) {
            isAvailable = true;
            cout << "Книга '" << title << "' возвращена в библиотеку" << endl;
        } else {
            cout << "Книга '" << title << "' и так в библиотеке" << endl;
        }
    }
    
    void displayInfo() const {
        cout << "\"" << title << "\" - " << author;
        cout << " [" << (isAvailable ? "Доступна" : "На руках") << "]" << endl;
    }
};

void exercise3() {
    Book book1;
    book1.setup("Война и мир", "Лев Толстой");
    book1.displayInfo();
    
    book1.borrow();         // Выдаём книгу
    book1.displayInfo();
    
    book1.borrow();         // Попытка выдать снова - ошибка
    
    book1.returnBook();     // Возвращаем
    book1.displayInfo();
}

// === ГЛАВНАЯ ФУНКЦИЯ ===
int main() {
    cout << "=== УРОК 14: КЛАССЫ, ОБЪЕКТЫ И ОСНОВЫ ООП ===" << endl;
    
    // Примеры из теории
    examples();
    
    // Упражнения
    cout << "\n=== УПРАЖНЕНИЕ 1: КЛАСС ПРЯМОУГОЛЬНИК ===" << endl;
    exercise1();
    
    cout << "\n=== УПРАЖНЕНИЕ 2: КЛАСС СЧЁТЧИК ===" << endl;
    exercise2();
    
    cout << "\n=== УПРАЖНЕНИЕ 3: КЛАСС КНИГА ===" << endl;
    exercise3();
    
    return 0;
}

/*
ДОМАШНИЕ ЗАДАНИЯ:

Задание 1: Класс для работы с температурой
Создай класс Thermostat:
- Приватные поля: текущая температура, целевая температура
- Сеттер для целевой температуры (от 10 до 35 градусов)
- Геттеры для обоих полей
- Метод для проверки: нужен ли нагрев
- Метод для вывода состояния

Задание 2: Класс для работы с оценками
Создай класс GradeBook:
- Приватные поля: имя ученика, массив оценок (5 штук), количество оценок
- Метод для добавления оценки (от 1 до 5, не больше 5 оценок)
- Метод для вычисления среднего балла
- Метод для вывода всех оценок

Задание 3: Класс для простого пароля
Создай класс PasswordLock:
- Приватное поле: пароль (строка)
- Приватное поле: количество попыток
- Метод setPassword (установить пароль)
- Метод checkPassword (проверить пароль, вернуть true/false)
- После 3 неудачных попыток - блокировка

ПРОВЕРОЧНЫЕ ВОПРОСЫ:

1. Что такое ООП и чем оно лучше процедурного программирования?
2. Назови три принципа ООП и объясни каждый своими словами.
3. В чём разница между классом и объектом? Приведи аналогию.
4. Что такое инкапсуляция? Приведи пример из реальной жизни.
5. Зачем нужны уровни доступа private и public?
6. Что такое геттер и сеттер? Зачем они нужны?
7. Почему плохо делать все поля public?
8. В чём разница между class и struct в C++?
9. Что произойдёт, если попытаться обратиться к private полю извне?
10. Зачем в сеттере делать проверку данных?

ЧТО ДАЛЬШЕ:
На следующем уроке мы изучим:
- Конструкторы (автоматическая инициализация объектов)
- Деструкторы (автоматическая очистка)
- Перегрузка конструкторов
- Список инициализации

ВРЕМЯ ИЗУЧЕНИЯ: 60-80 минут
ВРЕМЯ ПРАКТИКИ: 40-60 минут
ОБЩЕЕ ВРЕМЯ: 2-2.5 часа

===========================================
*/
