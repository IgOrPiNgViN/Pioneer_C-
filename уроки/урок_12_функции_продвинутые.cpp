/*
===========================================
УРОК 12: ФУНКЦИИ (ПРОДВИНУТЫЙ УРОВЕНЬ)
===========================================

ЦЕЛИ УРОКА:
- Освоить передачу параметров по ссылке и по указателю
- Изучить встроенные функции (inline)
- Понять статические переменные в функциях
- Научиться использовать оператор :: для доступа к глобальным переменным

ТЕОРЕТИЧЕСКАЯ ЧАСТЬ:

Напоминание: основы функций были изучены в уроке 9. Здесь мы рассмотрим продвинутые возможности.

КРАТКОЕ НАПОМИНАНИЕ (подробнее в уроке 9):
- Функция - именованный блок кода. Прототип: тип имя(параметры);
- Определение: тип имя(параметры) { тело; return значение; }
- Вызов: имя(аргументы);
- Передача по значению - создаётся копия (урок 9)
- Параметры по умолчанию - значения справа в списке (урок 9)

ПЕРЕДАЧА ПО ССЫЛКЕ:

Функция работает с оригинальной переменной, изменения сохраняются.

Пример:
void increment(int &x) {
    x++;  // изменяется оригинал
}

int num = 10;
increment(num);
cout << num << endl;  // выводит 11 (изменилось!)

Константная ссылка (для чтения):
void printValue(const int &x) {
    cout << x << endl;  // можно читать, но не изменять
    // x++;  // ОШИБКА! x константный
}

Когда использовать:
- Когда нужно изменить значение
- Для больших объектов (избегаем копирования)
- Для возврата нескольких значений

ПЕРЕДАЧА ПО УКАЗАТЕЛЮ:

Функция получает адрес переменной.

Пример:
void increment(int *x) {
    (*x)++;  // изменяется значение по адресу
}

int num = 10;
increment(&num);  // передаем адрес
cout << num << endl;  // выводит 11

Проверка на nullptr:
void printValue(int *ptr) {
    if (ptr != nullptr) {
        cout << *ptr << endl;
    }
}

Когда использовать:
- Когда указатель может быть nullptr
- Для массивов
- В C-стиле кода

ОБЛАСТЬ ВИДИМОСТИ: ОПЕРАТОР ::

Когда локальная переменная скрывает глобальную с тем же именем,
оператор :: позволяет обратиться к глобальной переменной:

int x = 100;  // глобальная

void func() {
    int x = 10;  // локальная (скрывает глобальную)
    cout << x << endl;        // 10 (локальная)
    cout << ::x << endl;      // 100 (глобальная, оператор ::)
}

РЕКУРСИЯ: ЧИСЛА ФИБОНАЧЧИ

(Факториал рассмотрен в уроке 9. Здесь - новый пример.)

Пример (числа Фибоначчи):
int fibonacci(int n) {
    if (n <= 1) {
        return n;  // базовый случай
    }
    return fibonacci(n - 1) + fibonacci(n - 2);  // рекурсия
}

ПЕРЕГРУЗКА ФУНКЦИЙ (кратко):

Несколько функций с одним именем, но разными параметрами.
Подробнее в уроке 9.

int add(int a, int b) { return a + b; }
double add(double a, double b) { return a + b; }

ВСТРОЕННЫЕ ФУНКЦИИ (inline):

Ключевое слово inline подсказывает компилятору встроить код функции.

Пример:
inline int square(int x) {
    return x * x;
}

Особенности:
- Код функции вставляется в место вызова (может быть быстрее)
- Увеличивает размер программы
- Компилятор может проигнорировать inline
- Используется для маленьких функций

СТАТИЧЕСКИЕ ПЕРЕМЕННЫЕ:

Статическая переменная сохраняет значение между вызовами.

Пример:
void counter() {
    static int count = 0;  // инициализируется один раз
    count++;
    cout << "Вызовов: " << count << endl;
}

counter();  // Вызовов: 1
counter();  // Вызовов: 2
counter();  // Вызовов: 3

Особенности:
- Инициализируется один раз
- Сохраняет значение между вызовами
- Существует всю жизнь программы

СИНТАКСИС УРОКА:

1. Передача по ссылке:
   void func(int& x) { x = 10; }    // оригинал изменяется

2. Передача по указателю:
   void func(int* x) { *x = 10; }
   func(&num);  // передаём адрес

3. Оператор :: для глобальной переменной:
   cout << ::globalVar << endl;

4. Встроенная функция:
   inline int square(int x) { return x * x; }

5. Статическая переменная:
   static int count = 0;  // внутри функции

ПРИМЕРЫ КОДА:
*/

#include <iostream>
using namespace std;

// Прототипы
void swapValues(int &a, int &b);
void incrementByPointer(int *x);
int fibonacci(int n);
inline int square(int x) { return x * x; }
void counter();

// Глобальная переменная
int globalVar = 100;

void examples() {
    // Передача по ссылке
    cout << "=== ПЕРЕДАЧА ПО ССЫЛКЕ ===" << endl;
    int x = 10, y = 20;
    cout << "До обмена: x = " << x << ", y = " << y << endl;
    swapValues(x, y);
    cout << "После обмена: x = " << x << ", y = " << y << endl;
    
    // Передача по указателю
    cout << "\n=== ПЕРЕДАЧА ПО УКАЗАТЕЛЮ ===" << endl;
    int num = 5;
    incrementByPointer(&num);
    cout << "После increment: num = " << num << endl;
    
    // Оператор ::
    cout << "\n=== ОПЕРАТОР :: ===" << endl;
    int globalVar = 999;  // локальная с тем же именем
    cout << "Локальная globalVar: " << globalVar << endl;
    cout << "Глобальная ::globalVar: " << ::globalVar << endl;
    
    // Рекурсия - Фибоначчи
    cout << "\n=== РЕКУРСИЯ (ФИБОНАЧЧИ) ===" << endl;
    for (int i = 0; i < 10; i++) {
        cout << "fib(" << i << ") = " << fibonacci(i) << endl;
    }
    
    // Inline функция
    cout << "\n=== INLINE ФУНКЦИЯ ===" << endl;
    cout << "square(7) = " << square(7) << endl;
    
    // Статическая переменная
    cout << "\n=== СТАТИЧЕСКАЯ ПЕРЕМЕННАЯ ===" << endl;
    counter();
    counter();
    counter();
}

void swapValues(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

void incrementByPointer(int *x) {
    if (x != nullptr) {
        (*x)++;
    }
}

int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

void counter() {
    static int count = 0;
    count++;
    cout << "Вызовов: " << count << endl;
}

/*
ПРАКТИЧЕСКИЕ УПРАЖНЕНИЯ:

Упражнение 1: Получение элемента по индексу через указатель
Создай функцию, которая возвращает указатель на элемент массива по индексу:
*/

int* getElementByIndex(int arr[], int size, int index) {
    if (index >= 0 && index < size) {
        return &arr[index];
    }
    return nullptr;
}

void exercise1() {
    int arr[] = {10, 20, 30, 40, 50};
    int size = 5;
    
    cout << "Массив: ";
    for (int i = 0; i < size; i++) cout << arr[i] << " ";
    cout << endl;
    
    int index;
    cout << "Введите индекс (0-" << size - 1 << "): ";
    cin >> index;
    
    int* ptr = getElementByIndex(arr, size, index);
    if (ptr != nullptr) {
        cout << "Элемент по индексу " << index << ": " << *ptr << endl;
    } else {
        cout << "Неверный индекс!" << endl;
    }
}

/*
Упражнение 2: Обмен значений по ссылке
Создай функцию для обмена трёх переменных циклически: a->b, b->c, c->a
Используй передачу по ссылке.
*/

void rotateThree(int &a, int &b, int &c) {
    int temp = a;
    a = c;
    c = b;
    b = temp;
}

void exercise2() {
    int a = 1, b = 2, c = 3;
    cout << "До: a=" << a << " b=" << b << " c=" << c << endl;
    rotateThree(a, b, c);
    cout << "После rotate: a=" << a << " b=" << b << " c=" << c << endl;
}

/*
Упражнение 3: Inline функция
Создай inline функцию для вычисления модуля числа и используй её:
*/

inline int myAbs(int x) {
    return (x < 0) ? -x : x;
}

void exercise3() {
    int num;
    cout << "Введите число: ";
    cin >> num;
    cout << "|" << num << "| = " << myAbs(num) << endl;
}

/*
Упражнение 4: Статический счётчик
Создай функцию, которая с помощью static переменной считает,
сколько раз она была вызвана, и выводит это число:
*/

void callCounter() {
    static int calls = 0;
    calls++;
    cout << "Функция вызвана " << calls << " раз(а)" << endl;
}

void exercise4() {
    cout << "Вызываем callCounter несколько раз:" << endl;
    callCounter();
    callCounter();
    callCounter();
}

/*
ДОМАШНИЕ ЗАДАНИЯ:

Задание 1: Функция для сортировки массива
Создай функцию для сортировки массива методом пузырька:
- Входные параметры: массив и его размер
- Функция должна изменить исходный массив
- Используй передачу по указателю

Задание 2: Функция с несколькими результатами по ссылке
Создай функцию minMax(int arr[], int size, int &minVal, int &maxVal),
которая через ссылки возвращает минимум и максимум массива.

Задание 3: Статический кэш
Создай функцию с static переменной, которая "запоминает"
последнее переданное значение и возвращает его при следующем вызове
с особым параметром (например, -1 означает "вернуть сохранённое").

ПРОВЕРОЧНЫЕ ВОПРОСЫ:

1. В чём разница между передачей по значению, по ссылке и по указателю?
2. Когда использовать константную ссылку?
3. Зачем нужен оператор ::?
4. Что делает ключевое слово inline?
5. Чем отличается static переменная от обычной локальной?

ЧТО ДАЛЬШЕ:
На следующем уроке мы изучим:
- Работа с файлами
- Чтение из файла
- Запись в файл
- Обработка ошибок при работе с файлами

ВРЕМЯ ИЗУЧЕНИЯ: 30-40 минут
ВРЕМЯ ПРАКТИКИ: 30-40 минут
ОБЩЕЕ ВРЕМЯ: 1-1.5 часа

===========================================
*/

int main() {
    cout << "=== УРОК 12: ФУНКЦИИ (ПРОДВИНУТЫЙ УРОВЕНЬ) ===" << endl;
    
    examples();
    
    cout << "\n=== УПРАЖНЕНИЕ 1: ЭЛЕМЕНТ ПО ИНДЕКСУ (УКАЗАТЕЛЬ) ===" << endl;
    exercise1();
    
    cout << "\n=== УПРАЖНЕНИЕ 2: ОБМЕН ПО ССЫЛКЕ ===" << endl;
    exercise2();
    
    cout << "\n=== УПРАЖНЕНИЕ 3: INLINE ФУНКЦИЯ ===" << endl;
    exercise3();
    
    cout << "\n=== УПРАЖНЕНИЕ 4: СТАТИЧЕСКИЙ СЧЁТЧИК ===" << endl;
    exercise4();
    
    return 0;
}
