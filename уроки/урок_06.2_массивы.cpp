/*
===========================================
УРОК 6.2: ДВУМЕРНЫЕ МАССИВЫ
===========================================

ЦЕЛИ УРОКА:
- Изучить двумерные массивы (матрицы)
- Понять инициализацию двумерных массивов
- Научиться работать с строками и столбцами
- Освоить основные алгоритмы работы с матрицами
- Изучить многомерные массивы

ТЕОРЕТИЧЕСКАЯ ЧАСТЬ:

ДВУМЕРНЫЕ МАССИВЫ В C++:

Двумерный массив (матрица) - это массив массивов. Его можно представить как таблицу
с строками и столбцами. Каждый элемент имеет два индекса: номер строки и номер столбца.

1. ОБЪЯВЛЕНИЕ ДВУМЕРНОГО МАССИВА:
   Синтаксис: тип_данных имя_массива[количество_строк][количество_столбцов];
   
   Примеры:
   int matrix[3][4];           // матрица 3x4 (3 строки, 4 столбца)
   double table[5][10];         // таблица 5x10
   char board[8][8];             // шахматная доска 8x8
   bool grid[100][100];          // сетка 100x100

2. ИНИЦИАЛИЗАЦИЯ ДВУМЕРНОГО МАССИВА:
   
   а) Полная инициализация:
   int matrix[3][4] = {
       {1, 2, 3, 4},
       {5, 6, 7, 8},
       {9, 10, 11, 12}
   };
   
   б) Частичная инициализация:
   int matrix[3][4] = {
       {1, 2},      // первая строка: {1, 2, 0, 0}
       {5, 6, 7},   // вторая строка: {5, 6, 7, 0}
       {9}          // третья строка: {9, 0, 0, 0}
   };
   
   в) Инициализация нулями:
   int matrix[3][4] = {0};  // все элементы = 0
   int matrix[3][4] = {};   // все элементы = 0
   
   г) Автоматическое определение размера строк:
   int matrix[][4] = {
       {1, 2, 3, 4},
       {5, 6, 7, 8}
   };  // количество строк определяется автоматически (2)
   
   д) Последовательная инициализация:
   int matrix[2][3] = {1, 2, 3, 4, 5, 6};
   // Эквивалентно:
   // matrix[0][0]=1, matrix[0][1]=2, matrix[0][2]=3,
   // matrix[1][0]=4, matrix[1][1]=5, matrix[1][2]=6

3. ДОСТУП К ЭЛЕМЕНТАМ:
   Синтаксис: arr[строка][столбец]
   
   Важно:
   - Первый индекс - номер строки (начинается с 0)
   - Второй индекс - номер столбца (начинается с 0)
   - matrix[0][0] - элемент в первой строке, первом столбце
   - matrix[i][j] - элемент в строке i, столбце j
   
   Примеры:
   int matrix[3][4] = {{1,2,3,4}, {5,6,7,8}, {9,10,11,12}};
   matrix[0][0] = 100;        // изменение элемента
   int x = matrix[1][2];      // чтение элемента (7)
   matrix[2][3] = matrix[0][0]; // копирование значения

4. РАЗМЕРЫ МАССИВА:
   
   а) Количество строк:
   int rows = sizeof(matrix) / sizeof(matrix[0]);
   
   б) Количество столбцов:
   int cols = sizeof(matrix[0]) / sizeof(matrix[0][0]);
   
   в) Общее количество элементов:
   int total = rows * cols;
   
   г) Использование констант:
   const int ROWS = 3;
   const int COLS = 4;
   int matrix[ROWS][COLS];

5. ПЕРЕБОР ЭЛЕМЕНТОВ ДВУМЕРНОГО МАССИВА:
   
   а) Вложенные циклы for:
   for (int i = 0; i < rows; i++) {
       for (int j = 0; j < cols; j++) {
           cout << matrix[i][j] << " ";
       }
       cout << endl;
   }
   
   б) Range-based цикл (C++11) - только для первого уровня:
   for (auto& row : matrix) {
       for (int element : row) {
           cout << element << " ";
       }
       cout << endl;
   }
   
   в) По строкам:
   for (int i = 0; i < rows; i++) {
       // обработка строки i
       for (int j = 0; j < cols; j++) {
           // работа с matrix[i][j]
       }
   }
   
   г) По столбцам:
   for (int j = 0; j < cols; j++) {
       // обработка столбца j
       for (int i = 0; i < rows; i++) {
           // работа с matrix[i][j]
       }
   }

6. ОСНОВНЫЕ ОПЕРАЦИИ С МАТРИЦАМИ:
   
   а) Заполнение матрицы:
   for (int i = 0; i < rows; i++) {
       for (int j = 0; j < cols; j++) {
           matrix[i][j] = i * cols + j;  // последовательная нумерация
       }
   }
   
   б) Заполнение пользователем:
   cout << "Введите элементы матрицы " << rows << "x" << cols << ":" << endl;
   for (int i = 0; i < rows; i++) {
       for (int j = 0; j < cols; j++) {
           cin >> matrix[i][j];
       }
   }
   
   в) Вывод матрицы:
   for (int i = 0; i < rows; i++) {
       for (int j = 0; j < cols; j++) {
           cout << matrix[i][j] << "\t";  // табуляция для выравнивания
       }
       cout << endl;
   }
   
   г) Копирование матрицы:
   for (int i = 0; i < rows; i++) {
       for (int j = 0; j < cols; j++) {
           matrix2[i][j] = matrix1[i][j];
       }
   }
   
   д) Сумма всех элементов:
   int sum = 0;
   for (int i = 0; i < rows; i++) {
       for (int j = 0; j < cols; j++) {
           sum += matrix[i][j];
       }
   }
   
   е) Поиск максимума/минимума:
   int max = matrix[0][0];
   int maxRow = 0, maxCol = 0;
   for (int i = 0; i < rows; i++) {
       for (int j = 0; j < cols; j++) {
           if (matrix[i][j] > max) {
               max = matrix[i][j];
               maxRow = i;
               maxCol = j;
           }
       }
   }

7. РАБОТА СО СТРОКАМИ И СТОЛБЦАМИ:
   
   а) Сумма элементов строки:
   int rowSum = 0;
   int rowIndex = 2;  // номер строки
   for (int j = 0; j < cols; j++) {
       rowSum += matrix[rowIndex][j];
   }
   
   б) Сумма элементов столбца:
   int colSum = 0;
   int colIndex = 1;  // номер столбца
   for (int i = 0; i < rows; i++) {
       colSum += matrix[i][colIndex];
   }
   
   в) Поиск максимального элемента в строке:
   int maxInRow = matrix[rowIndex][0];
   for (int j = 1; j < cols; j++) {
       if (matrix[rowIndex][j] > maxInRow) {
           maxInRow = matrix[rowIndex][j];
       }
   }
   
   г) Обмен строк:
   int row1 = 0, row2 = 1;
   for (int j = 0; j < cols; j++) {
       int temp = matrix[row1][j];
       matrix[row1][j] = matrix[row2][j];
       matrix[row2][j] = temp;
   }
   
   д) Обмен столбцов:
   int col1 = 0, col2 = 1;
   for (int i = 0; i < rows; i++) {
       int temp = matrix[i][col1];
       matrix[i][col1] = matrix[i][col2];
       matrix[i][col2] = temp;
   }

8. СПЕЦИАЛЬНЫЕ МАТРИЦЫ:
   
   а) Единичная матрица (квадратная, на главной диагонали 1, остальные 0):
   for (int i = 0; i < size; i++) {
       for (int j = 0; j < size; j++) {
           if (i == j) {
               matrix[i][j] = 1;
           } else {
               matrix[i][j] = 0;
           }
       }
   }
   
   б) Транспонирование матрицы (замена строк на столбцы):
   for (int i = 0; i < rows; i++) {
       for (int j = i + 1; j < cols; j++) {
           int temp = matrix[i][j];
           matrix[i][j] = matrix[j][i];
           matrix[j][i] = temp;
       }
   }
   
   в) Поворот матрицы на 90 градусов:
   // Требует создания временной матрицы
   
   г) Работа с главной диагональю (для квадратных матриц):
   for (int i = 0; i < size; i++) {
       matrix[i][i] = value;  // элемент на главной диагонали
   }
   
   д) Работа с побочной диагональю:
   for (int i = 0; i < size; i++) {
       matrix[i][size - 1 - i] = value;  // элемент на побочной диагонали
   }

9. МНОГОМЕРНЫЕ МАССИВЫ:
   
   C++ поддерживает массивы любой размерности:
   
   а) Трехмерный массив:
   int cube[3][4][5];  // 3 слоя, каждый 4x5
   cube[0][1][2] = 10;  // доступ к элементу
   
   б) Инициализация трехмерного массива:
   int cube[2][3][4] = {
       {  // первый слой
           {1, 2, 3, 4},
           {5, 6, 7, 8},
           {9, 10, 11, 12}
       },
       {  // второй слой
           {13, 14, 15, 16},
           {17, 18, 19, 20},
           {21, 22, 23, 24}
       }
   };
   
   в) Перебор трехмерного массива:
   for (int i = 0; i < layers; i++) {
       for (int j = 0; j < rows; j++) {
           for (int k = 0; k < cols; k++) {
               cout << cube[i][j][k] << " ";
           }
           cout << endl;
       }
       cout << endl;
   }

10. ОСОБЕННОСТИ ДВУМЕРНЫХ МАССИВОВ:
    - Элементы хранятся в памяти построчно (row-major order)
    - Первый индекс - строка, второй - столбец
    - Размер должен быть известен на этапе компиляции (для статических массивов)
    - Нет проверки границ
    - Можно использовать только первый размер как переменную (C99/C++)

ПРИМЕРЫ КОДА:
*/

#include <iostream>
using namespace std;

int main() {
    cout << "=== ДВУМЕРНЫЕ МАССИВЫ ===" << endl;
    
    // 1. Объявление и инициализация
    int matrix[3][4] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    
    cout << "\n1. Исходная матрица 3x4:" << endl;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            cout << matrix[i][j] << "\t";
        }
        cout << endl;
    }
    
    // 2. Размеры массива
    int rows = sizeof(matrix) / sizeof(matrix[0]);
    int cols = sizeof(matrix[0]) / sizeof(matrix[0][0]);
    cout << "\n2. Размеры: " << rows << " строк, " << cols << " столбцов" << endl;
    
    // 3. Доступ к элементам
    cout << "\n3. Доступ к элементам:" << endl;
    cout << "matrix[0][0] = " << matrix[0][0] << endl;
    cout << "matrix[1][2] = " << matrix[1][2] << endl;
    cout << "matrix[2][3] = " << matrix[2][3] << endl;
    
    // 4. Изменение элементов
    matrix[1][1] = 100;
    cout << "\n4. После изменения matrix[1][1] = 100:" << endl;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            cout << matrix[i][j] << "\t";
        }
        cout << endl;
    }
    
    // 5. Сумма всех элементов
    int sum = 0;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            sum += matrix[i][j];
        }
    }
    cout << "\n5. Сумма всех элементов: " << sum << endl;
    
    // 6. Сумма элементов строки
    int rowIndex = 1;
    int rowSum = 0;
    for (int j = 0; j < 4; j++) {
        rowSum += matrix[rowIndex][j];
    }
    cout << "\n6. Сумма элементов строки " << rowIndex << ": " << rowSum << endl;
    
    // 7. Сумма элементов столбца
    int colIndex = 2;
    int colSum = 0;
    for (int i = 0; i < 3; i++) {
        colSum += matrix[i][colIndex];
    }
    cout << "7. Сумма элементов столбца " << colIndex << ": " << colSum << endl;
    
    // 8. Поиск максимума
    int max = matrix[0][0];
    int maxRow = 0, maxCol = 0;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            if (matrix[i][j] > max) {
                max = matrix[i][j];
                maxRow = i;
                maxCol = j;
            }
        }
    }
    cout << "\n8. Максимальный элемент: " << max << " на позиции [" << maxRow << "][" << maxCol << "]" << endl;
    
    // 9. Единичная матрица (квадратная)
    const int SIZE = 4;
    int identity[SIZE][SIZE];
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            if (i == j) {
                identity[i][j] = 1;
            } else {
                identity[i][j] = 0;
            }
        }
    }
    cout << "\n9. Единичная матрица " << SIZE << "x" << SIZE << ":" << endl;
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            cout << identity[i][j] << "\t";
        }
        cout << endl;
    }
    
    // 10. Заполнение последовательными числами
    int seqMatrix[3][4];
    int counter = 1;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            seqMatrix[i][j] = counter++;
        }
    }
    cout << "\n10. Матрица, заполненная последовательными числами:" << endl;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            cout << seqMatrix[i][j] << "\t";
        }
        cout << endl;
    }
    
    return 0;
}

/*
ПРАКТИЧЕСКИЕ УПРАЖНЕНИЯ:

Упражнение 1: Вывод матрицы
Создай программу для вывода матрицы в красивом формате:
*/

void exercise1() {
    int matrix[4][5] = {
        {1, 2, 3, 4, 5},
        {6, 7, 8, 9, 10},
        {11, 12, 13, 14, 15},
        {16, 17, 18, 19, 20}
    };
    
    cout << "=== МАТРИЦА ===" << endl;
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 5; j++) {
            cout << matrix[i][j] << "\t";
        }
        cout << endl;
    }
}

/*
Упражнение 2: Сумма строк и столбцов
Создай программу, которая вычисляет сумму каждой строки и каждого столбца:
*/

void exercise2() {
    const int ROWS = 3;
    const int COLS = 4;
    int matrix[ROWS][COLS] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12}
    };
    
    cout << "=== СУММЫ СТРОК И СТОЛБЦОВ ===" << endl;
    
    // Суммы строк
    cout << "\nСуммы строк:" << endl;
    for (int i = 0; i < ROWS; i++) {
        int rowSum = 0;
        for (int j = 0; j < COLS; j++) {
            rowSum += matrix[i][j];
        }
        cout << "Строка " << i << ": " << rowSum << endl;
    }
    
    // Суммы столбцов
    cout << "\nСуммы столбцов:" << endl;
    for (int j = 0; j < COLS; j++) {
        int colSum = 0;
        for (int i = 0; i < ROWS; i++) {
            colSum += matrix[i][j];
        }
        cout << "Столбец " << j << ": " << colSum << endl;
    }
}

/*
Упражнение 3: Транспонирование матрицы
Создай программу для транспонирования квадратной матрицы:
*/

void exercise3() {
    const int SIZE = 4;
    int matrix[SIZE][SIZE] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12},
        {13, 14, 15, 16}
    };
    
    cout << "=== ТРАНСПОНИРОВАНИЕ МАТРИЦЫ ===" << endl;
    
    cout << "\nИсходная матрица:" << endl;
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            cout << matrix[i][j] << "\t";
        }
        cout << endl;
    }
    
    // Транспонирование (замена строк на столбцы)
    for (int i = 0; i < SIZE; i++) {
        for (int j = i + 1; j < SIZE; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
    
    cout << "\nТранспонированная матрица:" << endl;
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            cout << matrix[i][j] << "\t";
        }
        cout << endl;
    }
}

/*
Упражнение 4: Поиск элемента в матрице
Создай программу для поиска элемента в матрице:
*/

void exercise4() {
    const int ROWS = 3;
    const int COLS = 4;
    int matrix[ROWS][COLS] = {
        {5, 8, 12, 3},
        {9, 15, 7, 2},
        {11, 6, 4, 10}
    };
    
    int target;
    cout << "Введите число для поиска: ";
    cin >> target;
    
    bool found = false;
    int foundRow = -1, foundCol = -1;
    
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            if (matrix[i][j] == target) {
                found = true;
                foundRow = i;
                foundCol = j;
                break;
            }
        }
        if (found) break;
    }
    
    cout << "\n=== РЕЗУЛЬТАТ ПОИСКА ===" << endl;
    if (found) {
        cout << "Элемент " << target << " найден на позиции [" << foundRow << "][" << foundCol << "]" << endl;
    } else {
        cout << "Элемент " << target << " не найден" << endl;
    }
}

/*
Упражнение 5: Сумма главной диагонали
Создай программу для вычисления суммы элементов главной диагонали квадратной матрицы:
*/

void exercise5() {
    const int SIZE = 4;
    int matrix[SIZE][SIZE] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8},
        {9, 10, 11, 12},
        {13, 14, 15, 16}
    };
    
    cout << "=== СУММА ГЛАВНОЙ ДИАГОНАЛИ ===" << endl;
    
    cout << "\nМатрица:" << endl;
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            cout << matrix[i][j] << "\t";
        }
        cout << endl;
    }
    
    int diagonalSum = 0;
    for (int i = 0; i < SIZE; i++) {
        diagonalSum += matrix[i][i];
    }
    
    cout << "\nСумма элементов главной диагонали: " << diagonalSum << endl;
}

/*
Упражнение 6: Обмен строк
Создай программу для обмена двух строк в матрице:
*/

void exercise6() {
    const int ROWS = 4;
    const int COLS = 5;
    int matrix[ROWS][COLS] = {
        {1, 2, 3, 4, 5},
        {6, 7, 8, 9, 10},
        {11, 12, 13, 14, 15},
        {16, 17, 18, 19, 20}
    };
    
    cout << "=== ОБМЕН СТРОК ===" << endl;
    
    cout << "\nИсходная матрица:" << endl;
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            cout << matrix[i][j] << "\t";
        }
        cout << endl;
    }
    
    int row1 = 0, row2 = 2;
    // Обмен строк
    for (int j = 0; j < COLS; j++) {
        int temp = matrix[row1][j];
        matrix[row1][j] = matrix[row2][j];
        matrix[row2][j] = temp;
    }
    
    cout << "\nПосле обмена строк " << row1 << " и " << row2 << ":" << endl;
    for (int i = 0; i < ROWS; i++) {
        for (int j = 0; j < COLS; j++) {
            cout << matrix[i][j] << "\t";
        }
        cout << endl;
    }
}

/*
ДОМАШНИЕ ЗАДАНИЯ:

Задание 1: Умножение матриц
Создай программу для умножения двух матриц:
- Ввод двух матриц
- Проверка возможности умножения (число столбцов первой = числу строк второй)
- Вычисление произведения
- Вывод результата

Задание 2: Магический квадрат
Создай программу для проверки, является ли матрица магическим квадратом:
- Суммы всех строк равны
- Суммы всех столбцов равны
- Суммы диагоналей равны
- Все суммы равны между собой

Задание 3: Спиральное заполнение
Создай программу, которая заполняет матрицу по спирали:
- Начинается с угла
- Заполнение идет по часовой стрелке
- Числа идут последовательно (1, 2, 3, ...)

Задание 4: Поворот матрицы
Создай программу для поворота квадратной матрицы на 90 градусов по часовой стрелке:
- Создание временной матрицы
- Копирование элементов с поворотом
- Вывод результата

ПРОВЕРОЧНЫЕ ВОПРОСЫ:

1. Как объявить двумерный массив в C++?
2. Что означает matrix[i][j]?
3. Как найти количество строк и столбцов в массиве?
4. В каком порядке хранятся элементы двумерного массива в памяти?
5. Как транспонировать матрицу?
6. Что такое главная диагональ?
7. Как обменять две строки в матрице?
8. В чем разница между одномерным и двумерным массивом?
9. Можно ли создать трехмерный массив?
10. Как найти сумму элементов строки?

ЧТО ДАЛЬШЕ:
После изучения двумерных массивов рекомендуется:
- Вернуться к уроку 7 (Строки) для изучения работы со строками
- Изучить указатели (урок 8) для работы с динамическими массивами
- Освоить функции (урок 10) для передачи массивов в функции
- Изучить STL (урок 18) для работы с векторами и другими контейнерами

ВРЕМЯ ИЗУЧЕНИЯ: 60-70 минут
ВРЕМЯ ПРАКТИКИ: 50-60 минут
ОБЩЕЕ ВРЕМЯ: 2-2.5 часа

===========================================
*/

#include <iostream>
using namespace std;

int main() {
    // Основная программа
    cout << "=== УРОК 6.2: ДВУМЕРНЫЕ МАССИВЫ ===" << endl;
    
    // Выполняем упражнения
    cout << "\n=== УПРАЖНЕНИЕ 1: ВЫВОД МАТРИЦЫ ===" << endl;
    exercise1();
    
    cout << "\n=== УПРАЖНЕНИЕ 2: СУММЫ СТРОК И СТОЛБЦОВ ===" << endl;
    exercise2();
    
    cout << "\n=== УПРАЖНЕНИЕ 3: ТРАНСПОНИРОВАНИЕ ===" << endl;
    exercise3();
    
    cout << "\n=== УПРАЖНЕНИЕ 4: ПОИСК ЭЛЕМЕНТА ===" << endl;
    exercise4();
    
    cout << "\n=== УПРАЖНЕНИЕ 5: СУММА ДИАГОНАЛИ ===" << endl;
    exercise5();
    
    cout << "\n=== УПРАЖНЕНИЕ 6: ОБМЕН СТРОК ===" << endl;
    exercise6();
    
    return 0;
}

