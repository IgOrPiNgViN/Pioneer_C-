/*
===========================================
УРОК 11: СТРУКТУРЫ
===========================================

ЦЕЛИ УРОКА:
- Понять концепцию структур
- Изучить объявление и использование структур
- Научиться работать с массивами структур
- Освоить указатели на структуры
- Понять вложенные структуры

ТЕОРЕТИЧЕСКАЯ ЧАСТЬ:

СТРУКТУРЫ В C++:

Структура (struct) - это пользовательский тип данных, который группирует связанные переменные
разных типов под одним именем. Структуры позволяют создавать сложные типы данных,
объединяя простые типы в логические единицы.

ЗАЧЕМ НУЖНЫ СТРУКТУРЫ:

Вместо хранения связанных данных в отдельных переменных:
int studentAge = 18;
string studentName = "Иван";
double studentGrade = 4.5;

Можно объединить их в структуру:
struct Student {
    string name;
    int age;
    double grade;
};

Преимущества:
- Логическая группировка данных
- Удобство работы с данными
- Передача нескольких значений одной переменной
- Создание массивов однотипных объектов

1. ОБЪЯВЛЕНИЕ СТРУКТУРЫ:

   Синтаксис:
   struct ИмяСтруктуры {
       тип поле1;
       тип поле2;
       // ... другие поля
   };
   
   Важно: Не забудьте точку с запятой после закрывающей фигурной скобки!
   
   Примеры:
   // Простая структура для точки:
   struct Point {
       int x;
       int y;
   };
   
   // Структура для студента:
   struct Student {
       string name;
       int age;
       double grade;
       bool isScholarship;
   };
   
   // Структура для даты:
   struct Date {
       int day;
       int month;
       int year;
   };
   
   Правила именования:
   - Имя структуры обычно пишется с заглавной буквы (PascalCase)
   - Имена полей обычно пишутся с маленькой буквы (camelCase или snake_case)
   - Имена должны быть понятными и описательными

2. СОЗДАНИЕ ПЕРЕМЕННОЙ СТРУКТУРЫ:

   После объявления структуры можно создавать переменные этого типа.
   
   а) Объявление без инициализации:
   ИмяСтруктуры переменная;
   
   Пример:
   Point p1;  // поля не инициализированы (содержат "мусор")
   
   б) Объявление с инициализацией:
   ИмяСтруктуры переменная = {значение1, значение2, ...};
   
   Пример:
   Point p2 = {10, 20};  // x = 10, y = 20
   Student s1 = {"Иван", 18, 4.5, true};
   
   в) Инициализация по умолчанию (C++11):
   Point p3{};  // все поля инициализируются нулями
   
   г) Инициализация с указанием полей (C++20):
   Point p4 = {.x = 10, .y = 20};  // явное указание полей
   
   Важно: Порядок значений в инициализации должен соответствовать порядку полей!

3. ДОСТУП К ПОЛЯМ СТРУКТУРЫ:

   Для доступа к полям структуры используется оператор точки (.).
   
   Синтаксис: переменная.поле
   
   Примеры:
   Point p = {10, 20};
   p.x = 100;        // изменение поля x
   p.y = 200;        // изменение поля y
   int sum = p.x + p.y;  // чтение полей
   
   Student s = {"Анна", 17, 4.8, true};
   cout << s.name << endl;        // вывод имени
   s.age = 18;                    // изменение возраста
   s.grade = 5.0;                 // изменение оценки
   
   Чтение полей:
   int x = p.x;                   // чтение значения
   string name = s.name;          // чтение строки
   
   Изменение полей:
   p.x = 50;                      // изменение значения
   s.name = "Петр";              // изменение строки

4. ИНИЦИАЛИЗАЦИЯ СТРУКТУР:

   а) Инициализация списком (aggregate initialization):
   Point p = {10, 20};  // значения в порядке объявления полей
   
   б) Инициализация с указанием полей (C++20, designated initializers):
   Point p = {.x = 10, .y = 20};  // можно в любом порядке
   Point p = {.y = 20, .x = 10};  // тоже правильно
   
   в) Частичная инициализация:
   Point p = {10};  // x = 10, y = 0 (остальные поля нули)
   
   г) Инициализация по умолчанию:
   Point p{};  // x = 0, y = 0
   Point p;    // неинициализирована (содержит "мусор")
   
   д) Поэлементная инициализация:
   Point p;
   p.x = 10;
   p.y = 20;

5. УКАЗАТЕЛИ НА СТРУКТУРЫ:

   Можно создавать указатели на структуры и работать с ними.
   
   а) Создание указателя:
   Point p = {10, 20};
   Point *ptr = &p;  // указатель на структуру
   
   б) Доступ к полям через указатель:
   
   Способ 1: Оператор стрелки (->) - РЕКОМЕНДУЕТСЯ:
   ptr->x = 100;     // изменяет поле x
   ptr->y = 200;     // изменяет поле y
   int x = ptr->x;   // читает поле x
   
   Способ 2: Разыменование и точка:
   (*ptr).x = 100;   // эквивалентно ptr->x = 100
   (*ptr).y = 200;   // эквивалентно ptr->y = 200
   
   Важно: Оператор -> более удобен и читаем!
   
   Пример:
   Point p = {10, 20};
   Point *ptr = &p;
   
   cout << "x = " << ptr->x << endl;  // 10
   cout << "y = " << ptr->y << endl;  // 20
   
   ptr->x = 100;  // изменяет p.x
   ptr->y = 200;  // изменяет p.y

6. МАССИВЫ СТРУКТУР:

   Можно создавать массивы структур, как и массивы обычных типов.
   
   а) Объявление массива:
   Point points[5];  // массив из 5 точек
   Student students[10];  // массив из 10 студентов
   
   б) Инициализация массива:
   Point points[3] = {
       {10, 20},
       {30, 40},
       {50, 60}
   };
   
   Student students[3] = {
       {"Иван", 18, 4.5, true},
       {"Анна", 17, 4.8, false},
       {"Петр", 19, 3.2, true}
   };
   
   в) Доступ к элементам:
   points[0].x = 100;        // изменение первого элемента
   students[1].age = 18;     // изменение второго студента
   
   г) Перебор массива:
   for (int i = 0; i < 3; i++) {
       cout << "Студент " << i << ": " << students[i].name << endl;
       cout << "Возраст: " << students[i].age << endl;
   }
   
   д) Range-based цикл (C++11):
   for (Student& s : students) {
       cout << s.name << " - " << s.grade << endl;
   }

7. ВЛОЖЕННЫЕ СТРУКТУРЫ:

   Структуры могут содержать другие структуры как поля.
   
   Пример:
   struct Point {
       int x;
       int y;
   };
   
   struct Rectangle {
       Point topLeft;      // вложенная структура
       Point bottomRight;  // вложенная структура
   };
   
   а) Создание вложенной структуры:
   Rectangle rect = {{0, 0}, {10, 10}};
   // или:
   Rectangle rect;
   rect.topLeft = {0, 0};
   rect.bottomRight = {10, 10};
   
   б) Доступ к полям вложенной структуры:
   rect.topLeft.x = 5;           // доступ через точку
   rect.bottomRight.y = 15;
   
   int x = rect.topLeft.x;       // чтение значения
   
   в) Инициализация вложенных структур:
   Rectangle rect = {
       {0, 0},      // topLeft
       {10, 10}     // bottomRight
   };
   
   // С указанием полей (C++20):
   Rectangle rect = {
       .topLeft = {0, 0},
       .bottomRight = {10, 10}
   };

8. ПЕРЕДАЧА СТРУКТУР В ФУНКЦИИ:

   а) Передача по значению (копия):
   void printPoint(Point p) {
       cout << "(" << p.x << ", " << p.y << ")" << endl;
   }
   
   Недостаток: создается копия структуры (может быть медленно для больших структур)
   
   б) Передача по ссылке (рекомендуется):
   void printPoint(const Point& p) {
       cout << "(" << p.x << ", " << p.y << ")" << endl;
   }
   
   Преимущества:
   - Не создается копия (быстрее)
   - const гарантирует, что структура не изменится
   
   в) Передача по указателю:
   void printPoint(const Point* p) {
       cout << "(" << p->x << ", " << p->y << ")" << endl;
   }
   
   г) Изменение структуры в функции:
   void movePoint(Point& p, int dx, int dy) {
       p.x += dx;  // изменяет оригинальную структуру
       p.y += dy;
   }

9. ВОЗВРАТ СТРУКТУРЫ ИЗ ФУНКЦИИ:

   а) Возврат по значению:
   Point createPoint(int x, int y) {
       Point p = {x, y};
       return p;  // возвращает копию
   }
   
   б) Возврат по ссылке (осторожно!):
   Point& getPoint() {
       static Point p = {10, 20};  // static - существует после выхода
       return p;
   }
   
   Важно: Не возвращайте ссылку на локальную переменную!

10. СРАВНЕНИЕ СТРУКТУР:

    В C++ структуры нельзя сравнивать напрямую (кроме C++20 с оператором ==).
    
    Нужно сравнивать поля вручную:
    bool pointsEqual(const Point& p1, const Point& p2) {
        return (p1.x == p2.x) && (p1.y == p2.y);
    }
    
    Или использовать оператор == (C++20):
    struct Point {
        int x, y;
        bool operator==(const Point& other) const {
            return x == other.x && y == other.y;
        }
    };

11. РАЗМЕР СТРУКТУРЫ:

    Размер структуры обычно равен сумме размеров всех полей (с учетом выравнивания).
    
    Пример:
    struct Point {
        int x;    // 4 байта
        int y;    // 4 байта
    };
    // sizeof(Point) обычно равен 8 байтам
    
    Важно: Компилятор может добавлять padding (заполнение) для выравнивания!

12. ОСОБЕННОСТИ СТРУКТУР:

    - Поля могут быть любого типа (включая другие структуры)
    - Поля могут быть массивами
    - Поля могут быть указателями
    - Структуры можно вкладывать друг в друга
    - Структуры можно использовать как типы данных
    - В C++ структуры и классы почти идентичны (разница в доступе по умолчанию)

СИНТАКСИС УРОКА:

1. Объявление структуры:
   struct ИмяСтруктуры {
       тип поле1;
       тип поле2;
   };

2. Создание переменной структуры:
   ИмяСтруктуры имя;
   Student student1;

3. Доступ к полям:
   student1.name = "Иван";
   cout << student1.age;

4. Инициализация:
   Student s = {"Иван", 15, 4.5};

5. Массив структур:
   Student students[30];
   students[0].name = "Иван";

ПРИМЕРЫ КОДА:
*/

#include <iostream>
#include <string>
using namespace std;

// Объявление структуры
struct Point {
    int x;
    int y;
};

struct Student {
    string name;
    int age;
    double grade;
    bool isScholarship;
};

struct Rectangle {
    Point topLeft;
    Point bottomRight;
};

void examples() {
    // Создание и инициализация структуры
    cout << "=== ОСНОВЫ СТРУКТУР ===" << endl;
    Point p1 = {10, 20};
    Point p2 = {.x = 30, .y = 40};
    
    cout << "Точка p1: (" << p1.x << ", " << p1.y << ")" << endl;
    cout << "Точка p2: (" << p2.x << ", " << p2.y << ")" << endl;
    
    // Изменение полей
    p1.x = 100;
    p1.y = 200;
    cout << "После изменения p1: (" << p1.x << ", " << p1.y << ")" << endl;
    
    // Структура Student
    cout << "\n=== СТРУКТУРА STUDENT ===" << endl;
    Student student1 = {"Иван", 18, 4.5, true};
    
    cout << "Имя: " << student1.name << endl;
    cout << "Возраст: " << student1.age << endl;
    cout << "Оценка: " << student1.grade << endl;
    cout << "Стипендия: " << (student1.isScholarship ? "Да" : "Нет") << endl;
    
    // Вложенные структуры
    cout << "\n=== ВЛОЖЕННЫЕ СТРУКТУРЫ ===" << endl;
    Rectangle rect = {{0, 0}, {10, 10}};
    
    cout << "Прямоугольник:" << endl;
    cout << "Верхний левый угол: (" << rect.topLeft.x << ", " << rect.topLeft.y << ")" << endl;
    cout << "Нижний правый угол: (" << rect.bottomRight.x << ", " << rect.bottomRight.y << ")" << endl;
    
    // Указатели на структуры
    cout << "\n=== УКАЗАТЕЛИ НА СТРУКТУРЫ ===" << endl;
    Point *ptr = &p1;
    cout << "Через указатель: (" << ptr->x << ", " << ptr->y << ")" << endl;
    cout << "Альтернативный синтаксис: (" << (*ptr).x << ", " << (*ptr).y << ")" << endl;
}

/*
ПРАКТИЧЕСКИЕ УПРАЖНЕНИЯ:

Упражнение 1: Структура для работы с датой
Создай структуру для работы с датой:
*/

struct Date {
    int day;
    int month;
    int year;
};

void printDate(const Date &date) {
    cout << date.day << "." << date.month << "." << date.year << endl;
}

bool isLeapYear(int year) {
    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}

int daysInMonth(int month, int year) {
    int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    if (month == 2 && isLeapYear(year)) {
        return 29;
    }
    return days[month - 1];
}

void exercise1() {
    Date today = {15, 12, 2024};
    
    cout << "Сегодняшняя дата: ";
    printDate(today);
    
    cout << "Дней в месяце: " << daysInMonth(today.month, today.year) << endl;
    cout << "Високосный год: " << (isLeapYear(today.year) ? "Да" : "Нет") << endl;
}

/*
Упражнение 2: Массив структур студентов
Создай программу для работы с массивом студентов:
*/

void exercise2() {
    Student students[3] = {
        {"Анна", 17, 4.8, true},
        {"Петр", 18, 3.2, false},
        {"Мария", 17, 4.5, true}
    };
    
    cout << "=== СПИСОК СТУДЕНТОВ ===" << endl;
    for (int i = 0; i < 3; i++) {
        cout << "Студент " << (i + 1) << ":" << endl;
        cout << "  Имя: " << students[i].name << endl;
        cout << "  Возраст: " << students[i].age << endl;
        cout << "  Оценка: " << students[i].grade << endl;
        cout << "  Стипендия: " << (students[i].isScholarship ? "Да" : "Нет") << endl;
        cout << endl;
    }
    
    // Поиск студента с лучшей оценкой
    int bestStudent = 0;
    for (int i = 1; i < 3; i++) {
        if (students[i].grade > students[bestStudent].grade) {
            bestStudent = i;
        }
    }
    
    cout << "Лучший студент: " << students[bestStudent].name 
         << " с оценкой " << students[bestStudent].grade << endl;
}

/*
Упражнение 3: Структура для работы с комплексными числами
Создай структуру для работы с комплексными числами:
*/

struct Complex {
    double real;
    double imag;
};

Complex addComplex(const Complex &a, const Complex &b) {
    Complex result;
    result.real = a.real + b.real;
    result.imag = a.imag + b.imag;
    return result;
}

Complex multiplyComplex(const Complex &a, const Complex &b) {
    Complex result;
    result.real = a.real * b.real - a.imag * b.imag;
    result.imag = a.real * b.imag + a.imag * b.real;
    return result;
}

void printComplex(const Complex &c) {
    cout << c.real;
    if (c.imag >= 0) {
        cout << " + " << c.imag << "i";
    } else {
        cout << " - " << (-c.imag) << "i";
    }
}

void exercise3() {
    Complex c1 = {3, 4};
    Complex c2 = {1, 2};
    
    cout << "Комплексное число 1: ";
    printComplex(c1);
    cout << endl;
    
    cout << "Комплексное число 2: ";
    printComplex(c2);
    cout << endl;
    
    Complex sum = addComplex(c1, c2);
    cout << "Сумма: ";
    printComplex(sum);
    cout << endl;
    
    Complex product = multiplyComplex(c1, c2);
    cout << "Произведение: ";
    printComplex(product);
    cout << endl;
}

/*
Упражнение 4: Структура для работы с книгами
Создай структуру для работы с книгами:
*/

struct Book {
    string title;
    string author;
    int year;
    int pages;
    double price;
};

void exercise4() {
    Book books[3] = {
        {"Война и мир", "Лев Толстой", 1869, 1274, 1500.0},
        {"Евгений Онегин", "Александр Пушкин", 1833, 352, 800.0},
        {"Мастер и Маргарита", "Михаил Булгаков", 1967, 448, 1200.0}
    };
    
    cout << "=== КАТАЛОГ КНИГ ===" << endl;
    for (int i = 0; i < 3; i++) {
        cout << "Книга " << (i + 1) << ":" << endl;
        cout << "  Название: " << books[i].title << endl;
        cout << "  Автор: " << books[i].author << endl;
        cout << "  Год: " << books[i].year << endl;
        cout << "  Страниц: " << books[i].pages << endl;
        cout << "  Цена: " << books[i].price << " руб." << endl;
        cout << endl;
    }
    
    // Поиск самой дорогой книги
    int expensiveBook = 0;
    for (int i = 1; i < 3; i++) {
        if (books[i].price > books[expensiveBook].price) {
            expensiveBook = i;
        }
    }
    
    cout << "Самая дорогая книга: " << books[expensiveBook].title 
         << " за " << books[expensiveBook].price << " руб." << endl;
}

/*
ДОМАШНИЕ ЗАДАНИЯ:

Задание 1: Структура для работы с банковским счетом
Создай структуру для банковского счета:
- Номер счета
- Имя владельца
- Баланс
- Процентная ставка
- Функции для пополнения и снятия денег

Задание 2: Структура для работы с геометрическими фигурами
Создай структуры для различных фигур:
- Точка
- Круг (центр + радиус)
- Прямоугольник (две точки)
- Функции для вычисления площади и периметра

Задание 3: Структура для работы с автомобилями
Создай структуру для автомобиля:
- Марка и модель
- Год выпуска
- Пробег
- Цена
- Функции для поиска автомобилей по критериям

ПРОВЕРОЧНЫЕ ВОПРОСЫ:

1. Что такое структура?
2. Как объявить структуру?
3. Как создать переменную структуры?
4. Как получить доступ к полям структуры?
5. Можно ли создавать массивы структур?
6. Как работать с указателями на структуры?
7. Что такое вложенные структуры?

ЧТО ДАЛЬШЕ:
На следующем уроке мы изучим:
- Функции
- Объявление и определение функций
- Параметры и возвращаемые значения
- Перегрузка функций
- Рекурсивные функции

ВРЕМЯ ИЗУЧЕНИЯ: 50-60 минут
ВРЕМЯ ПРАКТИКИ: 40-50 минут
ОБЩЕЕ ВРЕМЯ: 1.5-2 часа

===========================================
*/

int main() {
    cout << "=== УРОК 11: СТРУКТУРЫ ===" << endl;
    
    examples();
    
    // Выполняем упражнения
    cout << "\n=== УПРАЖНЕНИЕ 1: РАБОТА С ДАТОЙ ===" << endl;
    exercise1();
    
    cout << "\n=== УПРАЖНЕНИЕ 2: МАССИВ СТУДЕНТОВ ===" << endl;
    exercise2();
    
    cout << "\n=== УПРАЖНЕНИЕ 3: КОМПЛЕКСНЫЕ ЧИСЛА ===" << endl;
    exercise3();
    
    cout << "\n=== УПРАЖНЕНИЕ 4: КАТАЛОГ КНИГ ===" << endl;
    exercise4();
    
    return 0;
}
























