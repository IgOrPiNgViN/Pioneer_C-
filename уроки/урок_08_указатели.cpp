/*
===========================================
УРОК 8: УКАЗАТЕЛИ И ССЫЛКИ
===========================================

ЦЕЛИ УРОКА:
- Понять концепцию указателей
- Изучить работу с указателями
- Освоить ссылки и их отличие от указателей
- Научиться работать с указателями на массивы
- Понять основы динамической памяти

ТЕОРЕТИЧЕСКАЯ ЧАСТЬ:

ПАМЯТЬ И АДРЕСА:

Каждая переменная хранится в памяти компьютера по определенному адресу.
Адрес - это номер ячейки памяти, где хранится значение переменной.
Указатели и ссылки позволяют работать с адресами переменных напрямую.

УКАЗАТЕЛИ В C++:

Указатель (pointer) - это переменная, которая хранит адрес другой переменной.
Указатели позволяют косвенно обращаться к данным и изменять их.

1. ОБЪЯВЛЕНИЕ УКАЗАТЕЛЯ:

   Синтаксис: тип_данных *имя_указателя;
   
   Примеры:
   int *ptr;        // указатель на int
   double *dPtr;    // указатель на double
   char *cPtr;      // указатель на char
   
   Важно:
   - Звездочка (*) может быть рядом с типом: int* ptr;
   - Или рядом с именем: int *ptr;
   - Или посередине: int * ptr;
   - Рекомендуется: int* ptr; (указывает, что ptr - это указатель на int)
   
   Неинициализированный указатель:
   int *ptr;  // содержит случайный адрес (опасно использовать!)

2. ПОЛУЧЕНИЕ АДРЕСА (оператор &):

   Оператор & (address-of) возвращает адрес переменной.
   Синтаксис: &переменная
   
   Примеры:
   int num = 42;
   int *ptr = &num;  // ptr хранит адрес переменной num
   
   cout << "Значение num: " << num << endl;      // 42
   cout << "Адрес num: " << &num << endl;          // адрес в памяти
   cout << "Значение ptr: " << ptr << endl;        // тот же адрес
   
   Важно: & возвращает адрес, а не значение!

3. РАЗЫМЕНОВАНИЕ (оператор *):

   Оператор * (dereference) получает значение по адресу, хранящемуся в указателе.
   Синтаксис: *указатель
   
   Примеры:
   int num = 42;
   int *ptr = &num;
   
   cout << *ptr << endl;  // выводит 42 (значение по адресу)
   *ptr = 100;            // изменяет значение num через указатель
   cout << num << endl;   // выводит 100
   
   Важно: *ptr - это значение переменной, на которую указывает ptr!

4. ИНИЦИАЛИЗАЦИЯ УКАЗАТЕЛЕЙ:

   а) Инициализация адресом переменной:
   int num = 42;
   int *ptr = &num;  // ptr указывает на num
   
   б) Инициализация NULL (nullptr в C++11):
   int *ptr = nullptr;  // указатель ни на что не указывает
   int *ptr = NULL;     // старый способ (не рекомендуется)
   
   в) Инициализация нулем:
   int *ptr = 0;  // эквивалентно nullptr
   
   Важно: Всегда инициализируйте указатели! Неинициализированный указатель
   может указывать на случайную область памяти и вызвать ошибку.

5. NULL И NULLPTR:

   - NULL - макрос, определенный как 0 (устаревший способ)
   - nullptr - ключевое слово C++11 (рекомендуется)
   - Оба означают "указатель ни на что не указывает"
   
   Примеры:
   int *ptr1 = nullptr;  // современный способ
   int *ptr2 = NULL;     // старый способ
   
   Проверка на nullptr:
   if (ptr == nullptr) {
       // указатель не инициализирован
   }
   
   if (!ptr) {  // короткая запись
       // указатель равен nullptr
   }

6. ИЗМЕНЕНИЕ ЗНАЧЕНИЙ ЧЕРЕЗ УКАЗАТЕЛИ:

   Указатели позволяют изменять значения переменных косвенно.
   
   Пример:
   int num = 10;
   int *ptr = &num;
   
   *ptr = 20;  // изменяет num через указатель
   cout << num << endl;  // выводит 20
   
   // Можно изменять указатель (на что он указывает):
   int num1 = 10, num2 = 20;
   int *ptr = &num1;
   *ptr = 100;  // num1 = 100
   ptr = &num2; // теперь ptr указывает на num2
   *ptr = 200;  // num2 = 200

ССЫЛКИ В C++:

Ссылка (reference) - это альтернативное имя для существующей переменной.
Ссылка не является отдельной переменной, она просто другое имя для той же памяти.

1. ОБЪЯВЛЕНИЕ ССЫЛКИ:

   Синтаксис: тип_данных &имя_ссылки = переменная;
   
   Примеры:
   int num = 42;
   int &ref = num;  // ref - это другое имя для num
   
   cout << num << endl;  // 42
   cout << ref << endl;  // 42 (то же значение)
   
   ref = 100;       // изменяет num
   cout << num << endl;  // 100

2. ОСОБЕННОСТИ ССЫЛОК:

   а) Должны быть инициализированы при объявлении:
   int num = 42;
   int &ref = num;  // правильно
   // int &ref;     // ОШИБКА! Ссылка должна быть инициализирована
   
   б) Не могут быть переназначены:
   int num1 = 10, num2 = 20;
   int &ref = num1;  // ref ссылается на num1
   // ref = num2;     // это не переназначение! Это присваивание значения
   // После этого: num1 = 20, ref все еще ссылается на num1
   
   в) Не могут быть NULL:
   // int &ref = nullptr;  // ОШИБКА! Ссылка не может быть NULL
   
   г) Синтаксически работают как обычные переменные:
   int num = 42;
   int &ref = num;
   ref = 100;  // не нужно разыменование, как с указателями

3. ИСПОЛЬЗОВАНИЕ ССЫЛОК:

   а) Как параметры функций (передача по ссылке):
   void swap(int &a, int &b) {
       int temp = a;
       a = b;
       b = temp;
   }
   
   б) Как возвращаемые значения:
   int& getMax(int &a, int &b) {
       return (a > b) ? a : b;
   }
   
   в) Для создания псевдонимов:
   int longVariableName = 42;
   int &short = longVariableName;  // короткое имя

РАЗНИЦА МЕЖДУ УКАЗАТЕЛЯМИ И ССЫЛКАМИ:

1. Инициализация:
   - Указатель: может быть неинициализирован (опасно!)
   - Ссылка: должна быть инициализирована при объявлении

2. NULL:
   - Указатель: может быть NULL (nullptr)
   - Ссылка: не может быть NULL

3. Переназначение:
   - Указатель: можно переназначить (указать на другую переменную)
   - Ссылка: нельзя переназначить (всегда ссылается на одну переменную)

4. Разыменование:
   - Указатель: требует * для доступа к значению
   - Ссылка: работает как обычная переменная (без *)

5. Арифметика:
   - Указатель: можно выполнять арифметические операции (ptr++, ptr--, ptr + n)
   - Ссылка: арифметика не имеет смысла

6. Память:
   - Указатель: занимает память (обычно 4 или 8 байт)
   - Ссылка: не занимает дополнительную память (это просто другое имя)

Примеры сравнения:
int num = 42;

// Указатель:
int *ptr = &num;
*ptr = 100;        // изменяет num
ptr = nullptr;    // можно сделать NULL
ptr = &otherVar;   // можно переназначить

// Ссылка:
int &ref = num;
ref = 100;         // изменяет num (без *)
// ref = nullptr;  // ОШИБКА!
// ref = otherVar; // это присваивание, не переназначение

УКАЗАТЕЛИ НА МАССИВЫ:

1. СВЯЗЬ МАССИВОВ И УКАЗАТЕЛЕЙ:

   Имя массива - это указатель на первый элемент массива.
   
   Пример:
   int arr[5] = {1, 2, 3, 4, 5};
   int *ptr = arr;  // эквивалентно int *ptr = &arr[0];
   
   // Оба способа доступа эквивалентны:
   arr[0] = 10;     // доступ через имя массива
   *ptr = 10;       // доступ через указатель
   ptr[0] = 10;     // указатель можно использовать как массив!

2. АРИФМЕТИКА УКАЗАТЕЛЕЙ:

   С указателями можно выполнять арифметические операции.
   
   а) Инкремент/декремент:
   int arr[5] = {1, 2, 3, 4, 5};
   int *ptr = arr;  // указывает на arr[0]
   ptr++;            // теперь указывает на arr[1]
   ptr--;            // вернулся к arr[0]
   
   б) Сложение/вычитание:
   int *ptr1 = arr;      // arr[0]
   int *ptr2 = arr + 2;  // arr[2]
   int *ptr3 = ptr2 - 1; // arr[1]
   
   в) Разность указателей:
   int diff = ptr2 - ptr1;  // разность = 2 (количество элементов)
   
   г) Индексация:
   ptr[0] = 10;  // эквивалентно *ptr = 10
   ptr[1] = 20;  // эквивалентно *(ptr + 1) = 20
   
   Важно: Арифметика указателей учитывает размер типа!
   int *ptr;
   ptr + 1;  // сдвиг на sizeof(int) байт (обычно 4 байта)

3. ДОСТУП К ЭЛЕМЕНТАМ МАССИВА:

   Есть несколько способов доступа к элементам массива:
   
   int arr[5] = {1, 2, 3, 4, 5};
   int *ptr = arr;
   
   // Способ 1: через имя массива
   arr[2] = 100;
   
   // Способ 2: через указатель с индексацией
   ptr[2] = 100;
   
   // Способ 3: через указатель с арифметикой
   *(ptr + 2) = 100;
   
   // Способ 4: через инкремент указателя
   ptr += 2;
   *ptr = 100;
   ptr -= 2;  // вернуться назад

4. ПЕРЕДАЧА МАССИВОВ В ФУНКЦИИ:

   Массивы передаются в функции как указатели.
   
   // Эти объявления эквивалентны:
   void func(int arr[]);
   void func(int *arr);
   
   Пример:
   void printArray(int arr[], int size) {
       for (int i = 0; i < size; i++) {
           cout << arr[i] << " ";
       }
   }
   
   // Вызов:
   int arr[5] = {1, 2, 3, 4, 5};
   printArray(arr, 5);

УКАЗАТЕЛИ НА УКАЗАТЕЛИ:

Можно создавать указатели на указатели (многоуровневая косвенность).

int num = 42;
int *ptr = &num;      // указатель на int
int **pptr = &ptr;    // указатель на указатель на int

cout << num << endl;    // 42
cout << *ptr << endl;   // 42
cout << **pptr << endl; // 42

Используется для:
- Динамических двумерных массивов
- Массивов указателей
- Сложных структур данных

КОНСТАНТНЫЕ УКАЗАТЕЛИ И ССЫЛКИ:

1. Указатель на константу:
   const int *ptr;  // нельзя изменить значение через ptr
   int num = 42;
   ptr = &num;
   // *ptr = 100;  // ОШИБКА! Значение константное

2. Константный указатель:
   int *const ptr = &num;  // нельзя изменить сам указатель
   // ptr = &other;  // ОШИБКА! Указатель константный

3. Константный указатель на константу:
   const int *const ptr = &num;  // нельзя изменить ни то, ни другое

4. Константная ссылка:
   const int &ref = num;  // нельзя изменить значение через ref
   // ref = 100;  // ОШИБКА!

ДИНАМИЧЕСКАЯ ПАМЯТЬ (основы):

1. Выделение памяти (new):
   int *ptr = new int;      // выделяет память для одного int
   int *arr = new int[10];  // выделяет память для массива из 10 int
   
2. Освобождение памяти (delete):
   delete ptr;      // освобождает память для одного объекта
   delete[] arr;    // освобождает память для массива
   
   Важно: Всегда освобождайте выделенную память!

Пример:
int *ptr = new int(42);  // выделение и инициализация
cout << *ptr << endl;    // 42
delete ptr;              // освобождение памяти
ptr = nullptr;           // обнуление указателя (хорошая практика)

ПРИМЕРЫ КОДА:
*/

#include <iostream>
using namespace std;

int main() {
    // Основы указателей
    cout << "=== ОСНОВЫ УКАЗАТЕЛЕЙ ===" << endl;
    int num = 42;
    int *ptr = &num;
    
    cout << "Значение переменной: " << num << endl;
    cout << "Адрес переменной: " << &num << endl;
    cout << "Значение указателя: " << ptr << endl;
    cout << "Значение по указателю: " << *ptr << endl;
    
    // Изменение значения через указатель
    *ptr = 100;
    cout << "После изменения через указатель: " << num << endl;
    
    // Ссылки
    cout << "\n=== ССЫЛКИ ===" << endl;
    int value = 50;
    int &ref = value;
    
    cout << "Значение переменной: " << value << endl;
    cout << "Значение ссылки: " << ref << endl;
    
    // Изменение значения через ссылку
    ref = 200;
    cout << "После изменения через ссылку: " << value << endl;
    
    // Указатели на массивы
    cout << "\n=== УКАЗАТЕЛИ НА МАССИВЫ ===" << endl;
    int arr[5] = {1, 2, 3, 4, 5};
    int *arrPtr = arr; // arr - указатель на первый элемент
    
    cout << "Элементы массива через указатель:" << endl;
    for (int i = 0; i < 5; i++) {
        cout << "arr[" << i << "] = " << *(arrPtr + i) << endl;
    }
    
    // Арифметика указателей
    cout << "\n=== АРИФМЕТИКА УКАЗАТЕЛЕЙ ===" << endl;
    int *ptr1 = &arr[0];
    int *ptr2 = &arr[2];
    
    cout << "ptr1 указывает на: " << *ptr1 << endl;
    cout << "ptr2 указывает на: " << *ptr2 << endl;
    cout << "Разность указателей: " << (ptr2 - ptr1) << endl;
    
    return 0;
}

/*
ПРАКТИЧЕСКИЕ УПРАЖНЕНИЯ:

Упражнение 1: Обмен значений через указатели
Создай функцию для обмена значений двух переменных через указатели:
*/

void swapWithPointers(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

void exercise1() {
    int x = 10, y = 20;
    
    cout << "До обмена: x = " << x << ", y = " << y << endl;
    swapWithPointers(&x, &y);
    cout << "После обмена: x = " << x << ", y = " << y << endl;
}

/*
Упражнение 2: Обмен значений через ссылки
Создай функцию для обмена значений двух переменных через ссылки:
*/

void swapWithReferences(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

void exercise2() {
    int x = 30, y = 40;
    
    cout << "До обмена: x = " << x << ", y = " << y << endl;
    swapWithReferences(x, y);
    cout << "После обмена: x = " << x << ", y = " << y << endl;
}

/*
Упражнение 3: Поиск максимума через указатели
Создай функцию для поиска максимального элемента в массиве через указатели:
*/

int findMaxWithPointers(int *arr, int size) {
    int max = *arr;
    for (int i = 1; i < size; i++) {
        if (*(arr + i) > max) {
            max = *(arr + i);
        }
    }
    return max;
}

void exercise3() {
    int arr[6] = {5, 8, 3, 12, 7, 2};
    
    cout << "Массив: ";
    for (int i = 0; i < 6; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    
    int max = findMaxWithPointers(arr, 6);
    cout << "Максимальный элемент: " << max << endl;
}

/*
Упражнение 4: Копирование строки через указатели
Создай функцию для копирования строки через указатели:
*/

void copyString(char *dest, const char *src) {
    while (*src != '\0') {
        *dest = *src;
        dest++;
        src++;
    }
    *dest = '\0';
}

void exercise4() {
    char source[50] = "Hello, World!";
    char destination[50];
    
    cout << "Исходная строка: " << source << endl;
    copyString(destination, source);
    cout << "Скопированная строка: " << destination << endl;
}

/*
Упражнение 5: Подсчет длины строки через указатели
Создай функцию для подсчета длины строки через указатели:
*/

int stringLength(const char *str) {
    int length = 0;
    while (*str != '\0') {
        length++;
        str++;
    }
    return length;
}

void exercise5() {
    char str[100];
    cout << "Введите строку: ";
    cin.ignore(); // очищаем буфер
    cin.getline(str, 100);
    
    int length = stringLength(str);
    cout << "Длина строки: " << length << endl;
}

/*
ДОМАШНИЕ ЗАДАНИЯ:

Задание 1: Функция для поиска подстроки
Создай функцию для поиска подстроки в строке через указатели:
- Входные параметры: строка и подстрока
- Возвращает позицию первого вхождения
- Используй только указатели

Задание 2: Функция для объединения строк
Создай функцию для объединения двух строк через указатели:
- Входные параметры: две строки
- Результат: объединенная строка
- Используй только указатели

Задание 3: Функция для реверса строки
Создай функцию для обращения строки через указатели:
- Входной параметр: строка
- Результат: обращенная строка
- Используй только указатели

ПРОВЕРОЧНЫЕ ВОПРОСЫ:

1. Что такое указатель?
2. Как получить адрес переменной?
3. Как разыменовать указатель?
4. В чем разница между указателями и ссылками?
5. Можно ли ссылке присвоить NULL?
6. Что такое арифметика указателей?
7. Как указатели связаны с массивами?

ЧТО ДАЛЬШЕ:
На следующем уроке мы изучим:
- Структуры (struct)
- Объявление и использование структур
- Массивы структур
- Указатели на структуры
- Вложенные структуры

ВРЕМЯ ИЗУЧЕНИЯ: 50-60 минут
ВРЕМЯ ПРАКТИКИ: 40-50 минут
ОБЩЕЕ ВРЕМЯ: 1.5-2 часа

===========================================
*/

#include <iostream>
using namespace std;

int main() {
    // Основная программа
    cout << "=== УРОК 8: УКАЗАТЕЛИ И ССЫЛКИ ===" << endl;
    
    // Выполняем упражнения
    cout << "\n=== УПРАЖНЕНИЕ 1: ОБМЕН ЧЕРЕЗ УКАЗАТЕЛИ ===" << endl;
    exercise1();
    
    cout << "\n=== УПРАЖНЕНИЕ 2: ОБМЕН ЧЕРЕЗ ССЫЛКИ ===" << endl;
    exercise2();
    
    cout << "\n=== УПРАЖНЕНИЕ 3: ПОИСК МАКСИМУМА ===" << endl;
    exercise3();
    
    cout << "\n=== УПРАЖНЕНИЕ 4: КОПИРОВАНИЕ СТРОКИ ===" << endl;
    exercise4();
    
    cout << "\n=== УПРАЖНЕНИЕ 5: ПОДСЧЕТ ДЛИНЫ СТРОКИ ===" << endl;
    exercise5();
    
    return 0;
}
























